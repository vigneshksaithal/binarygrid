# App Quickstart

This tutorial takes you through the step-by-step process of building your first app with Devvit. It should take you about 1 minute to complete. Once complete, you'll be able to see your app in a Reddit post

## Try it out

This starter template will [create an app like this for you](https://www.reddit.com/r/test_devvit_demos/comments/1mk4ql4/test3jsdevvit/) running on Reddit. It consists of a simple react-based counter app that calls backend functions.

## What you'll need

- Node.JS (version 22.2.0+)
- A code editor

## Environment setup

1. Install Node.JS and NPM ([instructions](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm))
2. Go to `https://developers.reddit.com/new` and choose the React template.
3. Go through the wizard. You will need to create a Reddit account and connect it to Reddit developers.
4. Follow the instructions on your terminal.

On success, you should see something like this:

```sh
Your Devvit authentication token has been saved to /Users/user.name/.devvit/token
Fetching and extracting the template...
Cutting the template to the target directory...
 üîß Installing dependencies...
 üöÄüöÄüöÄ Devvit app successfully initialized!
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚Ä¢ `cd my-app` to open your project directory       ‚îÇ
‚îÇ ‚Ä¢ `npm run dev` to develop in your test community  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Running your app

To run your app, `cd my-app` and then run `npm run dev`. You should see some logs start up that finish with:

```
‚ú® https://www.reddit.com/r/my-app_dev?playtest=my-app
```

The dev command automatically creates a development subreddit for your app and a test post for you to develop against. When you visit the url, it should look something like this.

![subreddit view](../assets/quickstart_game_subreddit.png)

Click the `Launch App` button to see your app!

## Devvit architecture

Once the project is checked out you'll see the following folder structure. Each of the folders is responsible for a part of your app:

**`src/client`:**  
This contains the client-side code for your application. You can use any web framework for your frontend (React, Vue, Angular, etc.). In this example, we chose react.

**`src/server`:**  
This contains the server-side code for your application. You will need to build a node-compatible server that handles API calls from the client-side. This is where you will write code for persistence, real-time message sharing between players, payment validation, etc. For this example we chose to use [express.JS](https://expressjs.com/)

**`src/shared`:**  
This contains classes, types and interfaces that are shared between the client and the server

**`devvit.json`:**  
This special file in the root of the project contains configurations for many of the Reddit-specific services that your application can use. For more information on `devvit.json` please refer to Configuration (devvit.json)

## Testing your app on a specific subreddit

You need to test your app on a subreddit. Your backend calls will not work when testing the app locally. For that we will be leveraging Devvit's Playtest tool. If you have a preference for a specific subreddit to playtest, change the `package.json` file to include your subreddit name in `dev:devvit`:

```javascript
"scripts": {
    //...
    "dev:devvit": "devvit playtest r/MY_PREFERRED_SUBREDDIT",
    //...
}
```

After adding the subreddit, use `npm run dev` to see the app on the new subreddit.

## Launching your app

Use our [launch guide](../guides/launch/launch-guide.md) to guide you where to get your first users.

When you are ready to launch your app, run `npm run launch`. This will upload your app to Reddit for our team to review. All apps must be reviewed before they can be installed on subreddits > 200 members. We will send you an email once your app is approved.

## Result

Now you have an application that runs inside of a Reddit post. You can now use this scaffolding to build your own application or app with Devvit.

## Further reading

- [Launching and Promoting your game](../guides/launch/launch-guide.md)


---

# Mod Tool Quickstart

Devvit allows you to build Mod Tools \- subreddit-installed applications that help moderators of that community to take action on conversations, keeping their communities safe and engaged.

This tutorial should take about 10 minutes to complete. Once complete, you'll be able to run a version of [Comment Mop](https://developers.reddit.com/apps/comment-nuke) in your test subreddit from your own codebase.

## What you'll need

- Node.JS (version 22.2.0+)
- A code editor

## Environment setup

1. Install Node.JS and NPM ([instructions](https://docs.npmjs.com/downloading-and-installing-node-js-and-npm))
2. Go to `https://developers.reddit.com/new` and choose Mod Tool under Other templates.
3. Go through the wizard. You will need to create a Reddit account and connect it to Reddit developers.
4. Follow the instructions on your terminal.

On success, you should see something like this:

```sh
Your Devvit authentication token has been saved to /Users/user.name/.devvit/token
Fetching and extracting the template...
Cutting the template to the target directory...
 üîß Installing dependencies...
 üöÄüöÄüöÄ Devvit app successfully initialized!
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ ‚Ä¢ `cd my-app` to open your project directory       ‚îÇ
‚îÇ ‚Ä¢ `npm run dev` to develop in your test community  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## Understanding the template

This tutorial lets you build your own version of [Comment Mop](https://developers.reddit.com/apps/comment-nuke). This tool allows moderators to remove and/or lock a full comment tree with a single menu action, avoiding repetitive mechanical tasks for community moderators.

### Create a menu action for moderators

The template leverages [Menu Actions](../capabilities/client/menu-actions) to enable moderators to Delete/Lock child comments of a post or comment. Menu Actions appear in the moderator menu:  
![menu actions](../assets/quickstart/quickstart-mod-tool-1.png)

The following code adds a menu action to comments. Once the app is installed on a subreddit, all moderators of the subreddit will see this option appear in the moderator menu for all comments.

```ts
Devvit.addMenuItem({
  label: 'Mop comments',
  description: 'Remove this comment and all child comments. This might take a few seconds to run.',
  location: 'comment',
  forUserType: 'moderator',
  onPress: (_event, context) => {
    context.ui.showForm(nukeForm);
  },
});
```

You'll notice that the `onPress` handler of this Menu Item action invokes a form with `context.ui.showForm()`. This will be explained in the next step.

### Devvit forms

Optionally, some moderator tools might need to request some additional information from the moderator before they can execute. In these cases we can leverage [Devvit Forms](../capabilities/client/forms). Comment Mop will display a form with some options regarding the action to be taken:

![forms](../assets/quickstart/quickstart-mod-tool-2.png)

The code that defines this form is:

```ts
// Define form fields
const nukeFields: FormField[] = [
  {
    name: 'remove',
    label: 'Remove comments',
    type: 'boolean',
    defaultValue: true,
  },
  {
    name: 'lock',
    label: 'Lock comments',
    type: 'boolean',
    defaultValue: false,
  },
  {
    name: 'skipDistinguished',
    label: 'Skip distinguished comments',
    type: 'boolean',
    defaultValue: false,
  },
] as const;

// Create form
const nukeForm = Devvit.createForm(
  () => {
    return {
      fields: nukeFields,
      title: 'Mop Comments',
      acceptLabel: 'Mop',
      cancelLabel: 'Cancel',
    };
  },
  // Form confirmation handler
  async ({ values }, context) => {
    if (!values.lock && !values.remove) {
      context.ui.showToast('You must select either lock or remove.');
      return;
    }

    if (context.commentId) {
      // ...
      // mop comments here
      // ...
    }
  }
);
```

The code that handles mopping the comment has been redacted from the sample above. It uses the Reddit API to traverse through the comments and perform the necessary actions. It will be explained in the next step.

### Reddit API

Apps made with Devvit can leverage the Reddit API to perform actions on comments, posts, get information about the current session, etc. The following code uses the Reddit API to find the child comments of the selected comment and delete all of them:

```ts
Devvit.configure({
  redditAPI: true,
});

export async function handleNuke(props: NukeProps, context: Devvit.Context) {
  try {
    // Get Comment and User from Reddit API
    const comment = await context.reddit.getCommentById(props.commentId);
    const user = await context.reddit.getCurrentUser();

    // Get Comments for Removal
    const comments: Comment[] = [];
    for await (const eachComment of getAllCommentsInThread(comment, skipDistinguished)) {
      comments.push(eachComment);
    }

    // Remove all comments
    await Promise.all(comments.map((comment) => comment.removed || comment.remove()));

    // Add to Mod Log
    try {
      await context.modLog.add({
        action: 'removecomment',
        target: props.commentId,
        details: 'comment-mop app',
        description: `u/${user.username} used comment-mop to ${verbage} this comment and all child comments.`,
      });
    } catch (e: unknown) {
      console.error(`Failed to add modlog for comment: ${props.commentId}.`, (e as Error).message);
    }

    // Show Toast with Result
    context.ui.showToast('Comments removed! Refresh the page to see the cleanup.');
  } catch (err: unknown) {
    context.ui.showToast('Mop failed! Please try again later.');
    console.error(err);
  }
}

// Helper Function - Depth-first traversal to get all comments in a thread
async function* getAllCommentsInThread(comment: Comment): AsyncGenerator<Comment> {
  const replies = await comment.replies.all();
  for (const reply of replies) {
    yield* getAllCommentsInThread(reply);
  }
}
```

## Building and Testing

To build and run your Mod tool, run the following commands on terminal:

```shell
npm run dev
```

If you didn't provide a test subreddit, one will be created for you. Once you run `npm run dev`, you will receive a link to test the mod tool in your test subreddit.

> Note that this mod tool is intended to be run on comments, so you will need to create a post and comment in your subreddit to see it.

## Result

Now you have a mod tool running from the code that you deployed yourself. Feel free to experiment with the code and run `npm run dev` again to see the changes. Notice that you don't need to worry about running costs for your mod tool, because Reddit hosts all Devvit applications for free. Also, if your mod tool becomes popular and gets installed by many subreddits, you may become eligible to earn [Reddit Developer Funds](../earn-money/reddit_developer_funds).

## Further reading

- Use our [launch guide](../guides/launch/launch-guide.md) to guide you where to get your first users.
- [Devvit Forms](../capabilities/client/forms)
- [Menu Actions](../capabilities/client/menu-actions)
- [Reddit Developer Funds](../earn-money/reddit_developer_funds)


---

---
slug: /
---

import IntroTilePanel from '@site/src/components/IntroPagesFeatures/IntroTilePanel.js';
import Rocket from '@site/docs/assets/introduction/SpotIllustration_Rocket.webp';
import SnooToolboxClipboard from '@site/versioned_docs/version-0.12/assets/introduction/SnooToolboxClipboard.webp';

# Devvit: Reddit's Developer Platform

<div style={{ display: 'flex', gap: '2rem', alignItems: 'flex-start', flexWrap: 'wrap' }}>
  <div style={{ flex: 1, minWidth: '300px' }}>
    
Devvit allows you to build interactive games and apps that live on Reddit. Build experiences that can earn up to $167,000 per app with our [Reddit Developer Funds](./earn-money/reddit_developer_funds).

Build community games like [Hot and Cold](https://www.reddit.com/r/hotandcold/), [Sword and Supper](https://www.reddit.com/r/SwordAndSupper/), and [Honk](https://www.reddit.com/r/RedditGames/), or create [custom mod tools](https://www.reddit.com/r/ModSupport/comments/1k6szsj/devvit_apps_for_moderation_a_list/) to empower your community.

**More examples:** [App Showcase](./examples/app-showcase)

**Questions?** Join [r/devvit](https://www.reddit.com/r/devvit/) or our [Discord](https://discord.gg/Cd43ExtEFS).

  </div>
  
  <div style={{ flex: '0 0 400px', minWidth: '300px' }}>
    

<div style={{ position: 'relative', width: '100%', paddingBottom: '56.25%', height: 0, overflow: 'hidden', marginBottom: '2rem' }}>
  <iframe 
    src="https://www.youtube.com/embed/1ZM1tKI4SnU" 
    title="Devvit Quickstart Tutorial" 
    frameborder="0" 
    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" 
    allowfullscreen
    style={{ position: 'absolute', top: 0, left: 0, width: '100%', height: '100%' }}
  ></iframe>
</div>

  </div>
</div>

<IntroTilePanel
  tiles={[
    {
      title: 'Build Games',
      image: Rocket,
      href: './introduction/intro-games',
      background: 'linear-gradient(135deg, #b2f7ef 0%, #4be18a 100%)',
      textColor: '#003820',
      imageSide: 'left',
      textAlign: 'left',
      alt: 'Build Games',
    },
    {
      title: 'Create Mod Tools',
      image: SnooToolboxClipboard,
      href: './introduction/intro-mod-tools',
      background: 'linear-gradient(135deg, #ffe066 0%, #ff7c53 100%)',
      textColor: '#5a2a00',
      imageSide: 'right',
      textAlign: 'left',
      alt: 'Create Mod Tools',
    },
  ]}
/>


---

import IntroTilePanel from '@site/src/components/IntroPagesFeatures/IntroTilePanel.js';
import Rocket from '@site/docs/assets/introduction/SpotIllustration_Rocket.webp';
import SnooToolboxClipboard from '@site/docs/assets/introduction/SnooToolboxClipboard.webp';

# Mod Tools on Reddit

Empower your community and streamline moderation with custom tools built on Devvit‚Äôs powerful platform.

Devvit is Reddit‚Äôs developer platform for building interactive, cross-platform tools and apps that run natively on Reddit.


## Why build mod tools on Reddit?
 Moderators can install an app on their subreddits to customize a community with bespoke mod tools, discussion bots, new governance tools, leaderboards, and more.

- Automate repetitive moderation tasks
- Improve community safety and engagement
- Streamline mod workflows


## Get started

<IntroTilePanel
  tiles={[
    {
      title: 'Quickstart',
      image: Rocket,
      href: '../quickstart/quickstart-mod-tool',
      background: 'linear-gradient(135deg, #b2f7ef 0%, #4be18a 100%)',
      textColor: '#003820',
      imageSide: 'left',
      textAlign: 'left',
      alt: 'Quickstart',
    },
    {
      title: 'Mod Resources',
      image: SnooToolboxClipboard,
      href: '../guides/best-practices/mod_resources',
      background: 'linear-gradient(135deg, #ffe066 0%, #ff7c53 100%)',
      textColor: '#5a2a00',
      imageSide: 'right',
      textAlign: 'left',
      alt: 'Three Strikes Tutorial',
    },
  ]}
/>

<hr style={{ margin: '2.5rem 0', border: 'none', borderTop: '2px solid #eee' }} />

## Community
Have questions or want to share your tool? Join [r/devvit](https://www.reddit.com/r/devvit/) or our [Discord](https://discord.gg/Cd43ExtEFS) to connect with other developers, get feedback, and show off your creations.



---


import IntroTilePanel from '@site/src/components/IntroPagesFeatures/IntroTilePanel.js';
import Celebration from '@site/docs/assets/introduction/SpotIllustration_Color_PartyHorn.webp';
import Rocket from '@site/docs/assets/introduction/SpotIllustration_Rocket.webp';

# Games on Reddit

Unleash your creativity and build engaging games inside Reddit communities with Devvit‚Äôs powerful platform. [Earn money](../earn-money/reddit_developer_funds) as players engage with your games.

Devvit is Reddit‚Äôs developer platform for building interactive, cross-platform games and apps that run natively on Reddit.

[Devvit Web](../capabilities/devvit-web/devvit_web_overview.mdx) lets you build Devvit apps using standard web technologies‚Äîlike React, Three.js, or Phaser‚Äîso you can use familiar tools and frameworks to create games for Reddit. It supports a traditional client/server split, and makes it easy to bring modern web games to Reddit using the tools you already know.

## Why build games on Reddit?

Reddit is home to millions of communities, each with its own culture and interests. With Devvit, you can create games that:

- Earn money through Reddit Gold payments and [Reddit Developer Funds](../earn-money/reddit_developer_funds.md)
- Reach Reddit‚Äôs massive audience
- Free hosting through our platform

## Ready to get started?

<IntroTilePanel
  tiles={[
    {
      title: 'Quickstart',
      image: Rocket,
      href: '../quickstart',
      background: 'linear-gradient(135deg, #b2f7ef 0%, #4be18a 100%)',
      textColor: '#003820',
      imageSide: 'left',
      textAlign: 'left',
      alt: 'Quickstart',
    },
    {
      title: 'Showcase',
      image: Celebration,
      href: '../examples/app-showcase',
      background: 'linear-gradient(135deg, #ffe066 0%, #ff7c53 100%)',
      textColor: '#5a2a00',
      imageSide: 'right',
      textAlign: 'left',
      alt: 'Showcase',
    },
  ]}
/>

<hr style={{ margin: '2.5rem 0', border: 'none', borderTop: '2px solid #eee' }} />


## Community

Have questions or want to share your game? Join [r/devvit](https://www.reddit.com/r/devvit/) or our [Discord](https://discord.gg/Cd43ExtEFS) to connect with other game developers, get feedback, and show off your creations.


---

# Template Library

Here are some starter projects and templates for your Devvit projects

## Devvit Web

[Devvit Web](../capabilities/devvit-web/devvit_web_overview.mdx) lets you use most web technologies to build your app, and we‚Äôve created a few templates with preinstalled libraries to help you get started. You can clone the repos just like you did in the quickstart.

- [React starter](https://github.com/reddit/devvit-template-react) - a boilerplate project scaffolding to help you kickstart your React project. It includes preinstalled libraries for Devvit, Vite, React, Express, Tailwind, and TypeScript for faster development.

- [Three.js starter](https://github.com/reddit/devvit-template-threejs) - a tower blocks example that shows you how to create 3D graphics in the browser. It includes preinstalled libraries for Devvit, Vite, Three.js, Express, and TypeScript. This template is great for visualizations and games.

- [Phaser starter](https://github.com/reddit/devvit-template-phaser) - a feature-rich HTML5 game framework for building 2D games in the browser. It includes preinstalled libraries for Devvit, Vite, Phaser, Express, and TypeScript. This template is good for handling physics, animations, input, sound, and asset management.

- [Hello world](https://github.com/reddit/devvit-template-hello-world/tree/main) - a simple template to build a counter app with no frameworks or opinions.

## Devvit Blocks

[Devvit Blocks](../capabilities/blocks/overview.md) lets you build applications that run inside of a Reddit post, using Reddit's own design system: optimized for performance and cross-platform compatibility.

- [Blocks Empty Template](https://github.com/reddit/devvit-template-blocks) - an empty project leveraging Devvit Blocks

- [Payments Template](https://github.com/reddit/devvit-template-payments) - a template that contains all boilerplate code to enable [Devvit Payments](../earn-money/payments/payments_overview.md) in your Blocks app.

## Mod Tools

Devvit allows you to build custom mod tools, to help Moderators on Reddit manage the conversations in their subreddits, keeping their communities safe.

- [Mod tool template](https://github.com/reddit/devvit-template-mod-tool) - a fully functional repository containing the code for Comment Mop, a mod tool that helps moderators clear a comment and all of its descendants. This template shows [Menu Actions](../capabilities/client/menu-actions.mdx) and [Reddit API](../capabilities/server/reddit-api.mdx) at work.

## Contributing

Do you have another template for a framework in mind? You can add to our library ‚Äî learn how to [contribute a template](https://github.com/reddit/devvit-examples)! Here‚Äôs an example of a [tRPC template](https://github.com/reddit/devvit-examples/tree/main/examples/trpc).


---

import PlaygroundTile from '@site/src/components/PlaygroundTile';
import PlaygroundTileMasonryGrid from '@site/src/components/PlaygroundTileMasonryGrid';

import BotBouncerImage from '@site/docs/assets/showcase/app-gallery/bot-bouncer.png';
import CommunityHomeImage from '@site/docs/assets/showcase/app-gallery/community-home.png';
import FlappyGooseImage from '@site/docs/assets/showcase/app-gallery/flappy-goose.png';
import HightierImage from '@site/docs/assets/showcase/app-gallery/hightier.png';
import PixelaryImage from '@site/docs/assets/showcase/app-gallery/pixelary.png';
import RiddonkulousImage from '@site/docs/assets/showcase/app-gallery/riddonkulous.png';
import SwordAndSupperImage from '@site/docs/assets/showcase/app-gallery/sword-and-supper.png';
import WhatTheImage from '@site/docs/assets/showcase/app-gallery/what-the.png';

# App Showcase

<PlaygroundTileMasonryGrid>
    <PlaygroundTile
        name="Pixelary"
        author="u/OppDagger"
        image={PixelaryImage}
        link="https://reddit.com/r/Pixelary"
    />
    <PlaygroundTile
        name="What The?!"
        author="Lil Snack Studios"
        image={WhatTheImage}
        link="https://reddit.com/r/WhatTheGame"
    />
    <PlaygroundTile
        name="Community Home"
        author="u/xenc"
        image={CommunityHomeImage}
        link="https://developers.reddit.com/apps/community-home"
    />
    <PlaygroundTile
        name="Flappy Goose"
        author="u/thejohnnyr"
        image={FlappyGooseImage}
        link="https://reddit.com/r/FlappyGoose"
    />    
    <PlaygroundTile
        name="Riddonkulous"
        author="u/hammertimestudios"
        image={RiddonkulousImage}
        link="https://reddit.com/r/Riddonkulous"
    />
    <PlaygroundTile
        name="Bot Bouncer"
        author="u/fsv"
        image={BotBouncerImage}
        link="https://developers.reddit.com/apps/bot-bouncer"
    />     
    <PlaygroundTile
        name="Sword and Supper"
        author="Cabbage Studios"
        image={SwordAndSupperImage}
        link="https://reddit.com/r/SwordAndSupperGame"
    />  
    <PlaygroundTile
        name="Hightier"
        author="u/mutualdisagreement"
        image={HightierImage}
        link="https://reddit.com/r/Hightier"
    />
    
</PlaygroundTileMasonryGrid>


---

# Reddit Developer Funds 2025

Reddit developer funds is a way for developers to earn money for the apps they build. Devs can earn up to $500,000 for their apps, or $167,000 per app.

## What we‚Äôre looking for

We want creative new apps that enrich the Reddit community through:

- An entirely new community created around the app, like [r/pixelary](https://www.reddit.com/r/Pixelary/) or [r/riddonkulous](https://www.reddit.com/r/riddonkulous/)
- A quality of life improvement that benefits hundreds of subreddits

Check your [eligibility from your settings page](https://developers.reddit.com/my/settings) or [enroll here](https://www.reddit.com/earn/enroll).

## How it works

The Reddit Developer Funds 2025 program (the ‚ÄúProgram‚Äù) will run from April 1, 2025 - Dec 31, 2025. The Program is focused on reach, and success will be measured by Daily Qualified Engagers and Qualified Installs defined as:

- A ‚ÄúQualified Install‚Äù means that a subreddit has your app installed and that subreddit: 1) has a minimum of 1,000 members, and 2) is eligible for monetization under Reddit‚Äôs Earn Policy (e.g., that is Safe for Work).

- A ‚ÄúDaily Qualified Engager‚Äù is a unique user that clicks and takes an action in your App for a specific day that: 1) occurs after April 1, 2025; 2) is logged in; 3) is in a subreddit that has a minimum of 200 members, and 4) is in a subreddit or on content that is eligible for monetization under Reddit‚Äôs Earn Policy (e.g., that is Safe for Work).

Measurement and eligibility are further defined in our terms. Please reference our [terms](https://support.reddithelp.com/hc/en-us/articles/27958169342996) when evaluating your app performance.

## Awards

| Tier              | Threshold                          | Payout  | Cumulative Payout |
| :---------------- | :--------------------------------- | :------ | :---------------- |
| Tier 1 - Engagers | 500 daily qualified engagers       | $500    | $500              |
| Tier 2 - Engagers | 1,000 daily qualified engagers     | $1,000  | $1,500            |
| Tier 3 - Engagers | 10,000 daily qualified engagers    | $5,000  | $6,500            |
| Tier 4 - Engagers | 25,000 daily qualified engagers    | $10,500 | $17,000           |
| Tier 5 - Engagers | 50,000 daily qualified engagers    | $25,000 | $42,000           |
| Tier 6 - Engagers | 100,000 daily qualified engagers   | $25,000 | $67,000           |
| Tier 7 - Engagers | 250,000 daily qualified engagers   | $25,000 | $92,000           |
| Tier 8 - Engagers | 1,000,000 daily qualified engagers | $75,000 | $167,000          |

The Daily Qualified Engagers threshold(s) are determined on a rolling seven day average, which means that the average Daily Qualified Engagers for your app over the prior seven days exceeds a given threshold.

| Tier     | Threshold              | Payout |
| :------- | :--------------------- | :----- |
| Installs | 250 qualified installs | $1000  |

The ‚ÄúQualified Install‚Äù threshold is met when your app exceeds the threshold below and maintains that number of qualified installs for a consecutive 7-day period.

### Eligibility restrictions:

Apps are not eligible if they previously received a payout under Developer Funds. However, if you have an app that you are excited about that previously received a payout under Developer Funds that would otherwise qualify, please reach out to us. We may consider exceptions to this restriction.

## Program rules

- After you create your developer account, you'll be able to onboard [here](https://www.reddit.com/earn/enroll)
- Apps can only qualify once for each reward tier.
- Don‚Äôt use spam, bots, or other forms of view manipulation, which may result in your disqualification from the program
- The community comes first. Apps should only be installed where relevant, useful, or enriching
- Up to three apps per developer can qualify for the funds program.
- Apps should be unique, original, and created by you.
  - A significant portion of the code and app UI should be original and follow our [rules](../devvit_rules.md)
  - Forked versions of apps must be significantly different in concept and function
  - You are welcome to use elements from example code or templates as a starting point for your project
- Apps must be on the latest version of Devvit

To be eligible for the program please sign up by [creating an app](https://developers.reddit.com/new). You must have a verified reddit email in order to receive onboarding instructions.

## Tracking

We want developers who are interested in this program to have the right tools for success - this includes tracking how your app is performing. Once you have signed up and onboarded onto the program [fill out this form](https://forms.gle/nywmjkvR6P6Ax2fM7) to receive regular updates on your app‚Äôs performance.

## We‚Äôre here to help

We want you to succeed! We can help facilitate conversations with moderators that you think would love your app. You can reach us at [r/devvit](https://www.reddit.com/r/devvit/) or become a member of our [Discord](https://discord.gg/Cd43ExtEFS) server for support.

## Terms and conditions

Additional terms and conditions apply; see the [Reddit Developer Funds Terms](https://support.reddithelp.com/hc/en-us/articles/27958169342996) for the complete rules and restrictions.


---

# UI Simulator

## Overview

Most Reddit users will see your app on a mobile device, so it‚Äôs important to know how your app will look and feel in that environment.  UI simulator is a specialized viewing mode that gives you tools to help you build, view, and test your app for a mobile audience. 


## Features

- **Mobile viewport simulation**: Displays your app in a mobile-sized container (matching common mobile device dimensions)
- **Size controls**: Toggle between mobile, desktop, and fullscreen views to test responsive behavior
- **Dark/light mode toggle**: Test your app's appearance in both light and dark themes

## Who can access UI simulator?

UI simulator mode is automatically enabled when you are the app developer and viewing the app in a subreddit where you are a moderator. You'll see it in the header of your webview app modal:

![UI Simulator Header](../../assets/ui_simulator_header.png)

## Using UI simulator

1. When viewport simulator is enabled, your app will initially load in mobile view
2. Use the viewport controls to switch between different view sizes:
   - Mobile (default): Shows your app in a mobile-sized container
   - Desktop: Expands to a wider viewport
   - Fullscreen: Takes up the entire screen
3. Use the dark/light mode toggle to test both color schemes

![UI simulator viewport](../../assets/ui_simulator_viewport.png)
![UI simulator theme](../../assets/ui_simulator_theme.png)

## Mobile-first development principles

Always test your app in mobile view first to validate that all critical features are accessible on small screens.

### Why mobile-first?

- Most Reddit users access content through mobile devices
- Mobile constraints help create more focused, efficient designs
- Better performance due to progressive enhancement

## Best practices

1. **Start small, scale up**

   - Begin with the mobile layout, adding complexity as the viewport size increases
   - Use progressive enhancement rather than graceful degradation

2. **Content prioritization**

   - Focus on essential content and features first
   - Optimize images and media for smaller screens
   - Stack content vertically for mobile
   - Consider thumb zones and reachability: keep important actions within easy reach

3. **Accessibility**

   - Ensure main touch targets are easily tappable & there is sufficient spacing between interactive elements
   - Maintain proper color contrast ratios in both themes
   - Use relative units (rem, em, %) over fixed pixels
   - Ensure text is readable without zooming

4. **Regular testing**

   - Test all new features in mobile view before desktop
   - Verify both dark and light mode appearances

Remember: Mobile users are your primary audience. If it works well on mobile, it will likely work well everywhere else.

Example of how to use a CSS media query to set different colors for light and dark mode:

```css
/* Light mode (default) */
:root {
  --bg-color: #ffffff;
  --text-color: #000000;
}

/* Dark mode */
@media (prefers-color-scheme: dark) {
  :root {
    --bg-color: #000000;
    --text-color: #ffffff;
  }
}
```


---

# Playtest

You can use playtest to see how your app works on Reddit.

Code changes you save during the playtest will automatically update your app on the playtest subreddit. This lets you see your app updates in real time and creates logs using real data.

## Start a playtest

1. Run `devvit upload` to add your app to the Apps directory. This automatically creates a playtest subreddit for you.
2. Run `devvit playtest` to start your app on your default subreddit.
3. The CLI will return the playtest subreddit link for your app.

## Playtest on an alternate subreddit

If you want to use an alternate subreddit (must have fewer than 200 subscribers) for your playtest, you can do this a couple of different ways:

- Run `devvit playtest [subreddit_name]`, or
- Set a default subreddit in one of these fields:
  - DEVVIT_SUBREDDIT environment variable
  - dev.subreddit field in devvit.json

If you set a default subreddit in your app, the `devvit playtest` command will use the default instead of the auto-generated subreddit.

## How do I find my playtest subreddit name?

Run `devvit playtest`. The CLI will output a link to your playtest subreddit

## About playtest subreddits

All playtest subreddits must have fewer than 200 subscribers.

The auto-generated playtest subreddit is created for you by u/devvit-dev-bot. This subreddit:

- Is private
- Makes you a moderator
- Has your app pre-installed
- Allows reddit admins to join your subreddit

:::note
If you need help, run `devvit playtest ‚Äî-help` for additional information.
:::

## View logs

Playtest continuously streams logs for your app installation. This will show in the output of your terminal where the playtest is running. Check out logs to learn more.

## Connect to client-side logs

To enable client-side logs, add the`?playtest=<app_name>` query parameter to your subreddit URL (e.g. http://reddit.com/r/devvit?playtest=pixelary-game). This allows client side logs to stream into Devvit playtest logs and live reloads your browser when there are changes.

:::note
This url is also shown in your terminal when you start a playtest.
:::

## End a playtest

Press Ctrl + C to exit the playtest.

Exiting the playtest does not uninstall the playtest version or revert your app back to a previous version. The playtest version you just tested will remain installed on the test subreddit.

## Revert your app

If you want to revert back to the latest non-playtest version of the app, run the following command from within your project directory:

```bash
$ devvit install <subreddit>
```

If you want to revert to a different version of your pre-playtest app, you can specify which version using the `install` command. Entering app name is optional if you are running this command from within your project directory.

```bash
$ devvit install <subreddit> [@version]
```

## Upload your app

If you‚Äôre satisfied with your playtest app and want to upload an installable version, run:

```bash
$ devvit upload
```

This will automatically bump your app version to the next patch release. For example, if your playtest version is 0.0.1.6, the upload command will remove the playtest version increment and change your app version to 0.0.2.

Once you publish your app to the Apps Directory, it will be available for users to install.


---

# Logs and Debugging

Stream log events from your installed app to your command line to troubleshoot your app. You can see 5,000 logs or up to 7 days of log events.

## Create logs

Any logs sent to `console` will be available via `devvit logs` for installed apps. For example, `console.log()`, `console.info()` and `console.error()` will produce logs with timestamps as expected.

The following example creates a basic app that simply creates a single log.

```typescript title="main.tsx"
import { Context, Devvit } from '@devvit/public-api';

Devvit.addMenuItem({
  location: 'post',
  label: 'Create a log!',
  onPress: (event, context) => {
    console.log('Action called!');
    context.ui.showToast(`Successfully logged!`);
  },
});

export default Devvit;
```

## Stream logs

To stream logs for an installed app, open a terminal and navigate to your project directory and run:

```bash
$ devvit logs <my-subreddit>
```

You can also specify the app name to stream logs for from another folder.

```bash
$ devvit logs <my-subreddit> <app-name>
```

You should now see logs streaming onto your console:

```bash
=============================== streaming logs for my-app on my-subreddit ================================
[DEBUG] Dec 8 15:55:23 Action called!
[DEBUG] Dec 8 15:55:50 Action called!
[DEBUG] Dec 8 15:57:29 Action called!
[DEBUG] Dec 8 15:57:32 Action called!
```

To exit the streaming logger, enter `CTRL + c`.

Currently, `console.log` calls will only stream when they are run from the server (not the client).

:::note

Custom post apps use a client-side runtime to speed up execution, so `console.log` calls won't always show up in Devvit logs or Devvit playtest commands. However, these calls will show up in other dev tools (like Chrome) when viewing the app during a playtest.

:::

## Historical logs

You can view historical logs by using the `--since=XX` flag. You can use the following shorthand:

- `Xs`: show logs in the past X seconds
- `Xm`: show logs in the past X minutes
- `Xh`: show logs in the past X hours
- `Xd`: show logs in the past X days
- `Xw`: show logs in the past X weeks

The following example will show logs from `my-app` on `my-subreddit` in the past day.

```bash
$ devvit logs <my-subreddit> --since=1d
```

You will now see historical logs created by your app on this subreddit:

```bash
=============================== streaming logs for my-app on my-subreddit ================================
[DEBUG] Dec 8 15:55:23 Action called!
[DEBUG] Dec 8 15:55:50 Action called!
[DEBUG] Dec 8 15:57:29 Action called!
[DEBUG] Dec 8 15:57:32 Action called!
```

To exit the streaming logger, enter `CTRL + c`.

## Playtest

While you are running [`playtest`](./playtest.md) in a subreddit, you will also be [streaming logs](#create-logs) from that community in your command line.


---

# Devvit CLI

The Devvit CLI enables you to create, upload, and manage your apps. It's the bridge between your codebase and Reddit.

:::note
We collect usage metrics when you use the Devvit CLI. For more information, see [Reddit‚Äôs Developer Terms](https://www.redditinc.com/policies/developer-terms) and the [Reddit Privacy Policy](https://www.reddit.com/policies/privacy-policy). You can opt out at any time by running `npx devvit metrics off`.
:::

## CLI Usage

### devvit create icons

Bundles all `SVG` files in the `/assets` folder into a new file (`src/icons.ts` by default). Enabling you to import local SVG assets in your app code.

#### Usage

```bash
$ npx devvit create icons [output-file]
```

#### Optional argument

- `output-file`

  Path to the output file. Defaults to `src/icons.ts`.

#### Generating the SVG bundle file

```bash
$ npx devvit create icons

$ npx devvit create icons "src/my-icons.ts"
```

#### Using the SVG files in app code

```tsx
import { Devvit } from '@devvit/public-api';
import Icons from './my-icons.ts';

Devvit.addCustomPostType({
  name: 'my-custom-post',
  render: (_context) => {
    return (
      <blocks>
        <image url={Icons['my-image.svg']} imageHeight="32px" imageWidth="32px" />
      </blocks>
    );
  },
});

export default Devvit;
```

### devvit help

Display help for devvit

#### Usage

```bash
$ npx devvit help
```

### devvit install

Install an app from the Apps directory to a subreddit that you moderate. You can specify a version to install or default to @latest (the latest version).

#### Usage

```bash
$ npx devvit install <subreddit> [app-name]@[version]
```

#### Required arguments

- `subreddit`

  Name of the installation subreddit. The "r/" prefix is optional.

#### Optional arguments

- `app-name`

  Name of the app to install (defaults to current project).

- `version`

  Specify the desired version (defaults to latest).

#### Examples

```bash
$ npx devvit install r/mySubreddit

$ npx devvit install mySubreddit my-app

$ npx devvit install r/mySubreddit my-app@1.2.3

$ npx devvit install r/mySubreddit @1.2.3
```

### devvit list apps

To see a list of apps you've published

#### Usage

```bash
$ npx devvit list apps
```

### devvit list installs

To see a list of all apps currently installed on a specified subreddit.

If no subreddit is specified, you'll get a list of all apps installed by you.

#### Usage

```bash
$ npx devvit list installs [subreddit]
```

#### Optional argument

- `subreddit`

  Name of the subreddit to look up installations for. The "r/" prefix is optional.

#### Examples

```bash
$ npx devvit list installs

$ npx devvit list installs mySubreddit

$ npx devvit list installs r/mySubreddit
```

### devvit login

Login to Devvit with your Reddit account in the browser.

#### Usage

```bash
$ npx devvit login [--copy-paste]
```

#### Optional argument

- `--copy-paste`

  If present, user will copy-paste code from the browser instead of the localhost.

### devvit logout

Logs the current user out of Devvit.

#### Usage

```bash
$ npx devvit logout
```

### devvit logs

Stream logs for an installation within a specified subreddit. You can see 5,000 logs or up to 7 days of log events.

#### Usage

```bash
$ npx devvit logs <subreddit> [app-name] [-d <value>] [-j] [-s <value>] [--verbose]
```

#### Required arguments

- `subreddit`

  The subreddit name. The "r/" prefix is optional.

- `app-name`

  The app name (defaults to working directory app).

#### Optional arguments

- `-d <value>, --dateformat <value>`

  Specify the format for rendering dates. Defaults to `MMM d HH:mm:ss` (Jan 15 18:30:03). See more about format options [here](https://date-fns.org/v2.29.3/docs/format).

- `-j, --json`

  Output JSON for each log line

- `-s <value>, --since <value>`

  Specify how far back you want the log streaming to start. Defaults to a `0m` (now) if omitted.

  Supported format:

  - `s` seconds
  - `m` minutes
  - `h` hours
  - `d` days
  - `w` weeks

  For example `15s`, `2w1d`, or `30m`.

- `--verbose`

  Displays the log levels and timestamps when the logs were created.

#### Examples

```bash
$ npx devvit logs r/mySubreddit

$ npx devvit logs mySubreddit my-app

$ npx devvit logs mySubreddit my-app --since 15s

$ npx devvit logs mySubreddit my-app --verbose
```

### devvit new

Create a new app.

#### Usage

```bash
$ npx devvit new [directory-name] [--here]
```

#### Optional arguments

- `directory-name`

  Directory name for your new app project. This creates a new directory for your app code. If no name is entered, you will be prompted to choose one.

- `--here`

  Generate the project here and not in a subdirectory.

#### Examples

```bash
$ npx devvit new

$ npx devvit new tic-tac-toe

$ npx devvit new --here
```

### devvit playtest

Installs your app to your test subreddit and starts a playtest session. A new version of your app is installed whenever you save changes to your app code, and logs are continuously streamed. Press `ctrl+c` to end the playtest session. Once ended, the latest installed version will remain unless you revert to a previous version using [`devvit install`](#devvit-install). For more information, see the [playtest page](playtest.md).

#### Usage

```bash
$ npx devvit playtest
```

#### Optional argument

- subreddit
  Name of a test subreddit with less than 200 subscribers that you moderate. The "r/" prefix is optional.

If no subreddit is specified, the command will use the first available option from:

- DEVVIT_SUBREDDIT environment variable
- dev.subreddit field in devvit.json
- The playtest subreddit stored for your app

If none exist, a new playtest subreddit will be automatically created.

### devvit settings list

List settings for your app. These settings exist at the global app-scope and are available to all instances of your app.

#### Usage

```bash
$ npx devvit settings list
```

### devvit settings set

Create and update settings for your app. These settings will be added at the global app-scope.

#### Usage

```bash
$ npx devvit settings set <my-setting>
```

#### Example

```bash
$ npx devvit settings set my-feature-flag
```

### devvit uninstall

Uninstall an app from a specified subreddit.

#### Usage

```bash
$ npx devvit uninstall <subreddit> [app-name]
```

#### Required argument

- `subreddit`

  Name of the subreddit. The "r/" prefix is optional. Requires moderator permissions in the subreddit.

- `app-name`

  Name of the app (defaults to the working directory app).

#### Examples

```bash
$ npx devvit uninstall r/mySubreddit

$ npx devvit uninstall mySubreddit

$ npx devvit uninstall mySubreddit my-app
```

### devvit update app

Update @devvit project dependencies to the currently installed CLI's version

#### Usage

```bash
$ npx devvit update app
```

### devvit upload

Upload an app to the App directory. By default the app is private and visible only to you.

#### Usage

```bash
$ npx devvit upload [--bump major|minor|patch|prerelease] [--copyPaste]
```

#### Optional arguments

- `--bump <option>`

  Type of version bump (major|minor|patch|prerelease)

- `--copyPaste`

  Copy-paste the auth code instead of opening a browser

### devvit version

Get the version of the locally installed Devvit CLI.

#### Usage

```bash
$ npx devvit version
```

### devvit view

Shows you the latest version of your app and some data about uploads. Includes an optional --json flag to get information in JSON format.

#### Usage‚Äã

```bash
$ npx devvit view [APPSLUG[@VERSION]] [--json] [version]
```

### devvit whoami

Display the currently logged in Reddit user.

#### Usage

```bash
$ npx devvit whoami
```

## Updating the CLI

There are currently two ways to update the Devvit CLI, depending on how you installed it.

<details>
  <summary>How do I know how I installed the CLI?</summary>
  <div>
    The easiest way to check how you installed the CLI is to run this command in your terminal:

    ```bash
    npm list -g --depth=0
    ```

    If you see a line that starts with `devvit@`, it means you have the CLI installed globally. If
    not, you likely have it installed as a dev dependency in your project - you can check this by
    looking for `devvit` in your project's `package.json` file under the `devDependencies` section.
    (If you don't see it in either place, you may not have the CLI installed at all, in which case,
    you can follow the [quickstart guide](../../quickstart) to install it.)
  </div>
</details>

### 1. If you installed the CLI as a dev dependency

This is the recommended way to install the CLI, as it ensures that your project uses a specific
version of the CLI, and makes it substantially easier to both update the CLI, and know what version
of the CLI you're using.

To update the CLI, run the following command in your project directory:

```bash
npm install --save-dev devvit@latest
```

(Or, if you're using a different package manager, use an equivalent command to update the `devvit`
package to the latest version, and save it as a development dependency. *DO NOT* save it as a
regular dependency - we don't need the CLI code uploaded with your app!)

### 2. If you installed the CLI globally

If you installed the CLI globally, ideally, you should uninstall the global version and install it
as a dev dependency in your project instead. To do this, inside your project, run the following
commands:

```bash
npm uninstall -g devvit
npm install --save-dev devvit@latest
```

If you still want to keep the CLI installed globally, you can update it by running the following
command:

```bash
npm install -g devvit@latest
```

This will update the global version of the Devvit CLI to the latest version. However, please note
that this is not recommended, as it can lead to inconsistencies between the CLI version used in
your project and the global version. It's best to use the CLI as a dev dependency in your project
to ensure that you're always using the same version across different environments.


---

# Migrating from useWebView to Devvit Web

This guide will migrate your legacy webview implementation (using useWebView inside of Blocks) to the official Devvit Web setup.

:::note
Apps can be partially migrated, you don't need to re-write everything!
:::

# Before

- Use postMessage for message passing
- App logic is isomorphic (server/client) in Blocks
- No client effects available

# After

- No postMessage required
- Use web native fetch() to server endpoints directly
- App logic is either on the client, or the server, with clear deliniation
- Client effects are available directly from web views

## Setting up devvit.json

The first thing you need to do is setup `devvit.json`.

Schema here: https://developers.reddit.com/schema/config-file.v1.json

`devvit.json` supports all capabilities previously available in the `Devvit` singleton, e.g. `Devvit.addCustomPostType()`. For the purposes of this guide, only the post rendering logic will be migrated.

### Understanding entrypoints

Your `devvit.json` must have entrypoints that point to **outputs** of your code. It is assumed that you have installed a bundler or can otherwise prepare static assets to appear in your dist folders.

```js
{
  "post": {
    "client": { // The output of your client app, probably /src/webroot
      "dir": "dist/client",
      "entry": "dist/client/index.html"
    }
  },
  "blocks": { // point to where you export Devvit singleton, probably src/main.tsx
    "entry": "src/devvit/main.tsx"
  },
  "server": { // new folder which will contain your Node server
    "entry": "dist/server/index.cjs"
  },
}
```

> You'll notice that the `blocks` entrypoint points to your TypeScript source file (`src/devvit/main.tsx`). This is because the Devvit CLI handles bundling for Blocks automatically. For your `client` and `server` entrypoints, however, you are responsible for bundling your code and pointing to the final output files in your `dist` directory.

### Building your client and server

The `devvit.json` configuration for `client` and `server` points to files in a `dist` directory. This means you're responsible for building your web and server assets. You can use any bundler you like, such as `vite`.

For example, your `package.json` might include scripts to output your assets to the `dist` folder.

Sample server vite config

```ts title="src/server/vite.config.ts
import { defineConfig } from 'vite';
import { builtinModules } from 'node:module';

export default defineConfig({
  ssr: {
    noExternal: true,
  },
  build: {
    ssr: 'index.ts',
    outDir: '../../dist/server',
    target: 'node22',
    sourcemap: true,
    rollupOptions: {
      external: [...builtinModules],

      output: {
        format: 'cjs',
        entryFileNames: 'index.cjs',
        inlineDynamicImports: true,
      },
    },
  },
});
```

Sample client Vite config (for React)

```ts title="src/client/vite.config.ts
import { defineConfig } from 'vite';
import tailwind from '@tailwindcss/vite';
import react from '@vitejs/plugin-react';

// https://vitejs.dev/config/
export default defineConfig({
  plugins: [react(), tailwind()],
  build: {
    outDir: '../../dist/client',
    sourcemap: true,
    chunkSizeWarningLimit: 1500,
  },
});
```

## Setting up your server endpoints

You can use any Node server for your server endpoints. This guide will use [Express](https://expressjs.com/).

1. Install Express

```
npm i express
```

2. Create a server index file

```ts title='src/server/index.ts'
import express from 'express';
// The `@devvit/server` package provides the tools to create a server,
// and gives you access to the request context.
import { createServer, context, getServerPort, redis } from '@devvit/web/server';

const app = express();

// Middleware for JSON body parsing
app.use(express.json());
// Middleware for URL-encoded body parsing
app.use(express.urlencoded({ extended: true }));
// Middleware for plain text body parsing
app.use(express.text());

const router = express.Router();

// The `context` object is automatically populated with useful information,
// like the current user's ID. Devvit's services, like redis, are also
// available via named imports from `@devvit/server`.
router.get<{ postId: string }, { message: string }>(
  '/api/hello',
  async (_req, res): Promise<void> => {
    const { userId } = context;
    res.status(200).json({
      message: `Hello ${userId}`,
    });
  }
);

router.get('/api/init', async (_req, res): Promise<void> => {
  res.json({ initialState: await redis.get('initialState') });
});

// Use router middleware
app.use(router);

// Get port from environment variable with fallback
const port = getServerPort();

const server = createServer(app);
server.on('error', (err) => console.error(`server error; ${err.stack}`));
server.listen(port, () => console.log(`http://localhost:${port}`));
```

### Calling your server endpoints

Now

Instead of using `postMessage`, your client-side code can now directly fetch the initial state from the `/api/init` endpoint we defined in the server.

```ts title=/src/client/app.ts
const res = await fetch('/api/init');
const data = await res.json();
console.log(data.initialState); // Logs the state from Redis
```

## Client effects

Previously, client effects were not available to your webview app. You had to pass a custom postMessage and handle that message in Blocks. Now, all client effects are available directly in the web-view through `@devvit/client`.

Before

```ts title=/src/devvit/main.tsx
const BlocksComponent = () => {
  const wv = useWebView({
    onMessage: (message) => {
      if (message.type === 'navigate_to') {
        ui.navigateTo(message.data.destination);
      }
    },
  });
};
```

```js title=webroot/app.js
window.postMessage({ type: 'navigate_to', destination: 'reddit.com' });
```

Now

```ts title=client/app.ts
import { navigateTo } from '@devvit/web/client';

navigateTo('reddit.com');
```


---

# Migrating from Devvit Web Experimental to Devvit Web

This guide will help you migrate from the experimental version of Devvit Web to the official Devvit Web setup. You must complete this migration to publish and grow your app.

> **Note**: Apps can be partially migrated, you don't need to re-write everything!

## How to identify if you're using the experimental version

You're using Devvit Web experimental if:

- Your project is based on either of these templates:
  - https://github.com/reddit/devvit-bolt-starter-experimental
  - https://github.com/reddit/devvit-template-react
- You have a `defineConfig` function in `src/devvit/main.tsx`

## What's changing

### Before (experimental)

- Uses `defineConfig` function in blocks
- Multiple `@devvit/X` packages for different capabilities
- Webroot-based dist outputs

### After (final version)

- Uses `devvit.json` for all configuration
- Single `@devvit/web` package with submodule imports
- Cleaner dist folder structure
- Clear separation of client and server code

## Migration steps

### 1. Install the latest @devvit/web

```bash
npm install @devvit/web@latest
```

### 2. Remove individual @devvit packages

Remove all individual capability packages:

```bash
npm uninstall @devvit/redis @devvit/server @devvit/client
```

### 3. Create your devvit.json

Create a `devvit.json` file in your project root. This replaces all configuration previously done through `defineConfig`:

```json
{
  "post": {
    "client": {
      "dir": "dist/client",
      "entry": "dist/client/index.html"
    }
  },
  "blocks": {
    "entry": "src/devvit/main.tsx"
  },
  "server": {
    "entry": "dist/server/index.cjs"
  }
}
```

> **Note**: Output directories no longer need to go to `webroot`. Use `dist/client` and `dist/server` for cleaner organization.

### 4. Update your imports

Change all imports from individual packages to the unified `@devvit/web` package:

#### Server-side imports

```typescript
// Before
import { redis } from '@devvit/redis';
import { createServer, context } from '@devvit/server';

// After
import { redis } from '@devvit/web/server';
import { createServer, context } from '@devvit/web/server';
```

#### Client-side imports

```typescript
// Before
import { navigateTo } from '@devvit/client';

// After
import { navigateTo } from '@devvit/web/client';
```

### 5. Remove defineConfig from main.tsx

In your `src/devvit/main.tsx`, remove the `defineConfig` function and any configuration it contained. This configuration now lives in `devvit.json`.

```typescript
// Before in src/devvit/main.tsx
import { defineConfig } from '@devvit/server';

export default defineConfig({
  // ... configuration
});

// After
// Simply export your Devvit instance or any Devvit.addX functions
import { Devvit } from '@devvit/web';

// Your Devvit setup code here
export default Devvit;
```

### 6. Reorganize your project structure

We recommend using a clean folder structure:

```
your-app/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ client/         # Your web app (React, etc.)
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.tsx
‚îÇ   ‚îú‚îÄ‚îÄ server/         # Your server endpoints
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
‚îÇ   ‚îî‚îÄ‚îÄ devvit/         # Blocks-related code (optional now)
‚îÇ       ‚îî‚îÄ‚îÄ main.tsx
‚îú‚îÄ‚îÄ dist/               # Built assets
‚îÇ   ‚îú‚îÄ‚îÄ client/
‚îÇ   ‚îî‚îÄ‚îÄ server/
‚îú‚îÄ‚îÄ devvit.json
‚îî‚îÄ‚îÄ package.json
```

### 7. Update your build configuration

Ensure your bundler outputs to the correct directories specified in `devvit.json`:

#### Server Vite config example

```typescript
export default defineConfig({
  ssr: {
    noExternal: true,
  },
  build: {
    emptyOutDir: false,
    ssr: 'index.ts',
    outDir: '../../dist/server',
    target: 'node22',
    sourcemap: true,
    rollupOptions: {
      external: [...builtinModules],
      output: {
        format: 'cjs',
        entryFileNames: 'index.cjs',
        inlineDynamicImports: true,
      },
    },
  },
});
```

#### Client Vite config example

```typescript
export default defineConfig({
  build: {
    outDir: '../../dist/client', // No longer webroot
  },
});
```

## Quick migration path

For the fastest migration:

1. **Start with a new template**: Clone https://github.com/reddit/devvit-template-react
2. **Move your server endpoints**: Copy your server code to the `src/server` folder
3. **Move your client app**: Copy your React/web code to the `src/client` folder
4. **Update imports**: Find and replace all `@devvit/X` imports with `@devvit/web/server` or `@devvit/web/client`
5. **Configure devvit.json**: Set up your entrypoints as shown above and update your app name
6. **Test locally**: Run `npm run dev` to ensure everything works

## Additional considerations

- All capabilities previously available through the experimental API are still available in the final version
- The context object and Redis access work the same way, just with different import paths
- Your app logic can still be split between client and server as before


---

# Migrating Blocks/Mod Tools to Devvit Web

This guide covers migrating traditional Devvit apps (using only Blocks or Mod Tools, without web views) to the Devvit Web setup. This is a straightforward migration that requires minimal changes.

## Overview

The migration primarily involves switching from `devvit.yaml` to `devvit.json` configuration. Your existing Blocks and Mod Tools code will continue to work with minimal changes.

## Migration steps

### 1. Create devvit.json

Create a `devvit.json` file in your project root with your app configuration:

```json
{
  "name": "your-app-name",
  "blocks": {
    "entry": "src/main.tsx",
    "triggers": ["onPostCreate"]
  }
}
```

Replace:

- `"your-app-name"` with your actual app name
- `"src/main.tsx"` with the path to your main Blocks entry point (where you export your Devvit instance)
- Include any triggers used in your src/main.tsx in the triggers array (or remove the parameter)

### 2. Remove devvit.yaml

Delete the `devvit.yaml` file from your project root. All configuration is now handled by `devvit.json`.

### 3. Handle static assets

If your app uses static assets (images, fonts, etc.) from an `assets` folder, you'll need to define this in update your `devvit.json` to point to these assets:

```json
{
  "name": "your-app-name",
  "blocks": {
    "entry": "src/main.tsx",
    "triggers": ["onPostCreate"]
  },
  "media": {
    "dir": "assets/"
  }
}
```

### 4. Test your app

Run your app locally to ensure everything works:

```bash
devvit playtest
```

## That's it!

Your Blocks and Mod Tools code should work as intended without any other changes. The Devvit runtime handles the compatibility layer automatically.

While your app will work with just these changes, we recommend exploring the additional capabilities available in Devvit Web over time.


---

# Launch Your App

Once your app is ready, you can launch it to users and moderators across Reddit. There are a few things you need to do to get your app "launch ready". This guide will walk you through that process.

Once you have created a polished app, you may also apply for **Reddit featuring**, which includes on-platform promotion and boosting of your app. Make sure to read this guide closely before filling out a [Reddit featuring request](https://forms.gle/pLEfhZFf6skc4Rto8).

We've broken the Devvit App Launch guide into four phases:

- **Alpha**: Use this stage to validate your core concept and catch major issues early.
- **Beta**: Test your game with real users on a public subreddit.
- **General Availability (GA)**: Share your app with all of Reddit!
- **Featured**: Work with the Reddit team to promote your app across the site.

How you launch your app in each of these stages depends on the type of app you‚Äôre building: a game or a community app.

## Games

Select your launch stage for instructions and guidelines to maximize your game's development.

<details>
  <summary>Alpha</summary>
  <div>
    <div>
   Share your app on r/Devvit to get technical feedback from other devs and Reddit admins:

1.  Create a public subreddit for your game.
2.  Create a game post in your public subreddit.
3.  [Cross-post](https://support.reddithelp.com/hc/en-us/articles/4835584113684-What-is-Crossposting) your game to r/Devvit with the flair "Feedback Friday‚Äù.

**Guidelines**

To get the best feedback:

- Post only once for a meaningful update (maybe a 2+ week gaps between versions)
- Respond to feedback within 24-48 hours.
- Test other developers' apps, too, to build relationships with your fellow devs.
</div>
    <br/>
  </div>
</details>

<details>
  <summary>Beta</summary>
  <div>
    <div>
  When you‚Äôre ready for broader player testing, launch your game on r/GamesOnReddit: 
  
  1. Go to your public subreddit for your game.
  2. Create a game post in your public subreddit.
  3. [Cross-post](https://support.reddithelp.com/hc/en-us/articles/4835584113684-What-is-Crossposting) a game post to r/GamesOnReddit with flair "Feedback‚Äù.

**Guidelines**

To get the best results, engage with players that give you feedback to start growing your community.

**Apps that have strong post engagement are great candidates for the next launch phase.**

</div>
    <br/>
  </div>
</details>

<details>
  <summary>GA</summary>
  <div>
    <div>
  When you're ready to publicly release your game:
  
  1. Upload the latest version of your app with `npx devvit upload`
  2. Publish your app with `npx devvit publish`
  
  Publishing your app triggers a thorough app review. Make sure your app has a detailed README in accordance with our [guidelines](https://www.reddit.com/r/Devvit/comments/1gfvsfy/all_published_apps_must_have_readmes/).

</div>
    <br/>
  </div>
</details>

### Best Practices for GAing your game

In order to have a successful app launch, please ensure your game has the following required and suggested best practices integrated into your experience. Reddit will not feature games that do not have these best practices implemented.

#### Required

- A compelling first screen - you **must** have a custom [splash screen](../../capabilities/server/splash-screen.mdx).
- Working across platforms - your game's viewport must be accessible and clean on both mobile and desktop platforms.
- Self-explanatory - anyone should be able to click into your post and have the context needed to play or participate.
- Responsive design - all screens should be visible within fullscreen, mobile, and desktop. Avoid unnecessary scrolls. Scrolling within inline webviews is prohibited.

#### Suggested

- A subscribe button - encourage re-engagement.
- Leaderboards - a view into a user's community standing.
- Community Flair - leverage [user flair](https://support.reddithelp.com/hc/en-us/articles/205242695-How-do-I-get-user-flair) to give users special distinction in the community (this can be done programmatically via the API).
- User Generated Content - provide ways for users to contribute (think: custom post comments, drawings, level builders, etc).

### Organic distribution

A published app is automatically shared with a small number of redditors, and engagement metrics will determine if our feed algorithms start to organically pick up your posts.

Key engagement metrics for games include:

- Contribution generation - comments and posts created
- Click through rate - how often users engage with your app
- Dwell time - how long users spend in your app
- Post score - upvotes vs downvotes ratio

Successful games will generate genuine conversation within each post, and create compelling content that engages redditors.

### Featuring with Reddit

Once your game has been published and approved, it may be featured by Reddit in one or more ways, such as:

- Games directory
- Featured promotional units
- Reddit's Game Feed
- Highlight in Reddit's Games sidebar

If you would like to apply for featuring, please [use this form](https://forms.gle/pLEfhZFf6skc4Rto8). We will respond to requests within two business days.

## Community apps

Apps that are built to use within a community (think mod tools like Bot Bouncer or interactive post apps like Community Hub) also follow the alpha, beta, and GA launch path.

<details>
  <summary>Alpha</summary>
  <div>
    <div>
   Share your app on r/Devvit to validate that your app solves real community problems:

1.  Create a public subreddit for your game.
2.  Create a game post in your public subreddit.
3.  On a Friday, cross-post your game to r/Devvit with the flair "Feedback Friday‚Äù.

You can also solicit feedback on the #mod-discussion Discord channel. Write a short description of your app that explains the problem your app solves, target community types, and how it fits into existing mod workflows. Include screenshots of the mode interface, and see what the community has to say.

**Guidelines**

To get the best feedback:

- Post only once for a meaningful update (maybe a 2+ week gaps between versions).
- Test your app with different permission levels (mod, approved user, regular user).
- Actively seek feedback from mods in your target communities.
</div>
    <br/>
  </div>
</details>

<details>
  <summary>Beta</summary>
  <div>
    <div>
  When you‚Äôre ready for broader testing, launch your game on a larger subreddit: 
  
  1. Upload the latest version of your app with `npx devvit upload`
  2. Publish your app as unlisted with `npx devvit publish`
  3. Once your app is approved, you can install it to a larger subreddit that you moderate for further testing. 
</div>
    <br/>
  </div>
</details>

<details>
  <summary>GA</summary>
  <div>
    <div>
When you're ready to publicly release your app, you‚Äôll need to add it to the Apps Directory:
  
  1. Run  `npx devvit publish --listed`
  2. Once your app is approved, it will be publicly available in the Apps Directory for any mod to install.
</div>
    <br/>
  </div>
</details>

## Resources

- Got questions? Join our Discord or post in [r/Devvit](https://www.reddit.com/r/Devvit/).
- Review the [rules](../../devvit_rules.md) before publishing.
- Learn more about [how to earn](../../earn-money/payments/payments_overview.md) for apps you launch.


---

# AI Tools

Devvit ships with first class support for common AI tools and patterns.

## LLMs.txt files

- https://developers.reddit.com/docs/llms.txt: Most useful for pasting into the chat UI of common LLMs BEFORE your prompt. Place your prompt last as models are auto-regressive.
- https://developers.reddit.com/docs/llms-full.txt: Useful for pasting into the chat UI of LLMs with large context windows (Gemini, Claude Sonnet 4). This lets you chat with the docs instead of reading them. It's easy to pollute your context if your using this for coding so we recommend only using this to learn about Devvit or plan. To execute, use `llms.txt` as most modern LLMs can tool call websites.

## Cursor Support

The React, ThreeJS, and Phaser templates ship with support for cursor rules out of the box. We've found these helps Cursor output high quality code for Devvit. Feel free to add and remove them as you see fit.

## MCP

Devvit ships with a MCP server to assist with agent driven development. There are two commands at the moment:

- `devvit_search`: Executes hybrid search over all of our docs. This is preferable to pasting in tons of docs since it can be more specific and lowers the risk of polluting your context.
- `devvit_logs` [experimental]: Queries for logs of your app and a subreddit to place into an agent's context. It can be fun any useful, and shows a glimpse of the future of AI Devvit! Try this after MCP is turned on in your agent, "find a bug in my app deployed to the subreddit <YOUR_SUBREDDIT_NAME> from the past week and a fix it". It might not work, but when it does, magic!

### Cursor

> Note that React, ThreeJS, and Phaser ship with first class support. All you have to do is run a template from [/new](https://developers.reddit.com/new) in cursor and you will see a popup at the bottom-left corner to enable.

1.  In your project, ensure a `.cursor` directory exists at the root. Create it if necessary.
2.  Inside `.cursor`, create or open the `mcp.json` file.
3.  Paste the following configuration into `mcp.json`:

    ```json
    {
      "mcpServers": {
        "devvit": {
          "command": "npx",
          "args": ["-y", "@devvit/mcp"]
        }
      }
    }
    ```

4.  Save the file.
5.  Check [Cursor](https://www.cursor.com/)'s **Settings/MCP** section. The Devvit MCP server should show an active status (green indicator). You might need to click "Refresh" if it doesn't appear immediately.

### Claude Code

```sh
claude mcp add devvit -- npx -y @devvit/mcp
```

Things should work after that!

### Claude Desktop

1.  Open the [Claude desktop](https://claude.ai/download) application and go to **Settings**.
2.  Navigate to the **Developer** tab and click **Edit Config**.
3.  Add the Devvit server configuration:

```json
{
  "mcpServers": {
    "devvit": {
      "command": "npx",
      "args": ["-y", "@devvit/mcp"]
    }
  }
}
```

4.  Save the configuration file and restart the Claude desktop application.
5.  When starting a new chat, look for the MCP icon (hammer); the Devvit server should now be listed as available.

### Visual Studio Code (Copilot)

1.  Ensure your project root contains a `.vscode` directory. Create one if it's missing.
2.  Create or open the `mcp.json` file within the `.vscode` directory.
3.  Insert the following configuration:

    ```json
    {
      "servers": {
        "devvit": {
          "command": "npx",
          "args": ["-y", "@devvit/mcp"]
        }
      }
    }
    ```

4.  Save `mcp.json`.
5.  In the Copilot chat panel within [Visual Studio Code](https://code.visualstudio.com/), ensure you're in "Agent" mode. The tool icon should now indicate that Devvit MCP tools are available for use.

Refer to the [official Copilot documentation](https://code.visualstudio.com/docs/copilot/chat/mcp-servers) for further details on VS Code MCP integration.

### Testing the Connection

With your AI tool configured, you should now be able to leverage the Devvit MCP server. A good way to test this is to ask your AI assistant a question that requires accessing Devvit resources, for example: "Search the Devvit docs for information on redis."

If you encounter problems, refer to the official Devvit documentation or reach out in the [Discord](https://discord.com/invite/R7yu2wh9Qz).


---

# Mod Resources

Devvit apps are programs hosted and run on Reddit‚Äôs Developer Platform. Moderators can install an app on their subreddits to customize a community with bespoke mod tools, discussion bots, new governance tools, games, leaderboards, and more.

:::note
Some apps are for everyone in the community, while others are limited to moderators in the community. Moderation apps will often have buttons that show up in, or with, the mod shield icon.
:::

## Understanding apps

### Permissions

Apps may require certain permissions in order to work on your subreddit. These permissions are listed on the app detail pages in the [Community Apps](https://developers.reddit.com) directory.

Permissions fall in one of three categories.

| **Category**               | **Description**                                                                                                   |
| -------------------------- | ----------------------------------------------------------------------------------------------------------------- |
| UI                         | Permissions the app needs for the UI elements it uses.                                                            |
| User data handling         | Permissions the app needs for the way it manages user data.                                                       |
| Mod permissions (required) | Permission the app needs to create an [app account](#app-accounts) with everything permissions on your subreddit. |

You can see the permissions an app requires on the app details page, install details page, and in the CLI.

![app permissions](../../assets/app_permissions.png)

### App accounts

Each app has an ‚Äúapp account‚Äù‚Äô which is basically a user account for the app. The app account may take mod actions, write posts/comments, or send messages programmatically. These accounts are not human-operated or logged into.

Currently, app accounts are granted full mod permissions. In the future they will be granted more granular permissions based on the actions they need to take.

![app details](../../assets/app_account_everything_permissions.png)

### Configuration settings

Some apps have settings that let you control how the app is configured to work on your subreddit. You can enable a specific setting or select options the developer provided to further customize your subreddit‚Äôs experience.

![app details](../../assets/app_config_screen.png)

## How to install an app

Go to the [Apps](https://developers.reddit.com/apps) directory and select an app. This opens the app detail page. Click the red **Install** button, select the subreddit you want to add the app to, and presto! You‚Äôve just installed an app.

![app details](../../assets/app-details-5.png)

## Safety

### Data privacy

Each installation of an app has its own data storage. This means that the data used by the app cannot interact with or share data with other communities, or with other apps . If the app you are installing uses external web services, the app will come with a separate privacy agreement with the developer.

If you uninstall an app from a subreddit, your app history will be lost. Be sure you want to remove an app before clicking "uninstall," because you won't be able to retrieve the data or settings if you reinstall the app at a later date.

### App review

Admins review the source code and test functionality of every app made publicly available. Apps going through major updates or with greater security risk go through the review process for each new version.

### Reporting an app

If you believe an app is in violation of Reddit‚Äôs sitewide content policies, is creating issues, or otherwise having negative impacts to communities it‚Äôs installed in, please contact our team via r/modsupport.


---

# Building Community Games

Reddit offers a unique platform for a new category of social games. This guide will help you create engaging community games that thrive in Reddit's ecosystem with lessons from some of the games we've seen so far.

## What are community games?

Community games are asynchronous multiplayer experiences built specifically for Reddit's platform. They leverage Reddit's unique social dynamics and content mechanics to create engaging, bite-sized gaming experiences that scale from single players to thousands.

## Why build a community game?

- _Played by millions_ - Successful apps will be distributed to millions of users in their home feed
- _Hosted services_ - We provide hosting, storage (redis), and robust backend capabilities (realtime, scheduler, trigger) with every app
- _Build once, play everywhere_ - if you build your apps once they will run on web, android, and iOS
- _Monetization opportunities_ - We have reddit developer funds and payments to reward successful apps with a handful of new monetization opportunities coming soon.

## Core design principles

### 1. Keep it bite-sized

- Focus on quick, discrete gameplay loops
- Reduce "time to fun" - players should be having fun within seconds
- Small scope = faster development and easier maintenance
- Example: [r/ChessQuiz](https://reddit.com/r/chessquiz) offers daily chess puzzles rather than full matches

### 2. Design for the feed

- Create an eye-catching first screen that stands out
- Include a clear, immediate call to action
- Remember: You're competing with cat videos and memes
- Example: [r/Pixelary](https://reddit.com/r/pixelary]) shows the drawing canvas right in the feed

### 3. Build content flywheels

Reddit posts naturally decay after a few days. Your game needs a strategy to stay relevant:

**Option A: Scheduled content**

- Daily/weekly challenges
- Automated post creation
- Regular tournaments or events
- Example: [r/Sections](https://reddit.com/r/sections) posts a new puzzle every day

**Option B: Player-generated content**

- Players create content through gameplay
- Each play creates new posts/comments
- Moderation systems for quality control
- Example: [r/CaptionContest](https://reddit.com/r/captioncontest) turns each submission into new content

### 4. Embrace asynchronous play

Benefits:

- Players can participate anytime
- Lower commitment (one move vs. entire game)
- Larger player pool across time zones
- Better scalability

### 5. Scale from one to many

Your game should be fun at any player count:

- Single-player baseline experience
- Scales smoothly as more players join
- Uses leaderboards to create competition
- Example: [r/DarkDungeonGame](https://reddit.com/r/darkdungeongame) works solo but gets better with more players solving together

## Successful examples

### Pixelary (drawing and guessing game)

- **Primary loop**: Draw (hard) ‚Üí Creates posts
- **Secondary loop**: Guess (easy) ‚Üí Creates comments (optionally)
- **Why it works**:
  - Clear mental model
  - Two-tiered engagement
  - Natural content generation
  - Scales with community size

### ChezzQuiz (competitive chess puzzles)

- **Core loop**: Daily puzzles with competitive solving
- **Why it works**:
  - Consistent content schedule
  - Built-in competition
  - Leverages existing chess knowledge
  - Clear success metrics

## Best practices checklist

- ‚úÖ Create your own subreddit
- ‚úÖ Can be played in under 2 minutes
- ‚úÖ Has a striking first impression
- ‚úÖ Creates new content regularly
- ‚úÖ Works for both 1 and 1000 players
- ‚úÖ Has clear user actions
- ‚úÖ Includes social elements
- ‚úÖ Uses moderation tools

## Common pitfalls to avoid

- ‚ùå Complex game rules
- ‚ùå Long time commitments
- ‚ùå Requiring specific player counts
- ‚ùå Dependency on real-time interactions
- ‚ùå Unclear first actions
- ‚ùå No content refresh strategy

## Key takeaway

The most successful Reddit community games create interesting content while being played, establishing a virtuous cycle of engagement and discovery. Focus on simplicity, scalability, and social interaction to make your game thrive.


---

---
slug: /examples/tutorials/mod-tool
---

# Build a Mod Tool - Three Strikes


---

# Support This App

You can ask users to contribute to your app‚Äôs development by adding the ‚Äúsupport this app‚Äù feature. This allows users to support your app with Reddit gold in exchange for some kind of award or recognition.

## Requirements

1. You must give something in return to users who support your app. This could be unique custom user flair, an honorable mention in a thank you post, or another creative way to show your appreciation.
2. The ‚ÄúSupport this App‚Äù purchase button must meet the Developer Platform‚Äôs [design guidelines](./payments_add.md#design-guidelines).

## How to integrate app support

### Create the product

Use the Devvit CLI to generate the [product configuration](./payments_add.md#register-products).

```tsx
devvit products add support-app
```

### Add a payment handler

The [payment handler](./payments_add.md#complete-the-payment-flow) is where you award the promised incentive to your supporters. For example, this is how you can award custom user flair:

```tsx
addPaymentHandler({
  fulfillOrder: async (order, context) => {
    const username = await context.reddit.getCurrentUsername();
    if (!username) {
      throw new Error('User not found');
    }

    const subredditName = await context.reddit.getCurrentSubredditName();

    await context.reddit.setUserFlair({
      text: 'Super Duper User',
      subredditName,
      username,
      backgroundColor: '#ffbea6',
      textColor: 'dark',
    });
  },
});
```

### Initiate purchases

Next you need to provide a way for users to support your app:

- If you use Devvit blocks, you can use the ProductButton helper to render a purchase button.
- If you use webviews, make sure that your design follows the [design guidelines](./payments_add.md#design-guidelines) to [initiate purchases](./payments_add.md#initiate-orders).

![Support App Example](../../assets/support_this_app.png)

Here's how you create a ProductButton in blocks:

```tsx
import { usePayments, useProducts } from '@devvit/payments';
import { ProductButton } from '@devvit/payments/helpers/ProductButton';
import { Devvit } from '@devvit/public-api';

Devvit.addCustomPostType({
  render: (context) => {
    const { products } = useProducts(context);
    const payments = usePayments((result: OnPurchaseResult) => {
      if (result.status === OrderResultStatus.Success) {
        context.ui.showToast({
          appearance: 'success',
          text: 'Thanks for your support!',
        });
      } else {
        context.ui.showToast(
          `Purchase failed! Please try again.`
        );
      }
    });
   const supportProduct = products.find(products.find((p) => p.sku === 'support-app');
   return (
     <ProductButton
       product={supportProduct}
       onPress={(p) => payments.purchase(p.sku)}
     />
   );
})
```

## Example

At [r/BirbGame](https://www.reddit.com/r/BirbGame/), they created the Birb Club. Members can join the club and get exclusive flair to support the app.

![Birb gif](../../assets/support_birbclub.gif)

![Birb flair](../../assets/support_birbclub_flair.png)


---

# Test Payments

Use the payments sandbox environment to simulate payment transactions. All apps automatically start in the payments sandbox.

## Start a playtest

To test your app:

1. Run `devvit upload` to upload your app to the Apps directory.
2. Run `devvit playtest` <test-subreddit-name> .

Once you start a playtest session, a new pre-release version of your app is automatically created and installed on your test subreddit. The pre-release version has a fourth decimal place, so if your current app is 0.0.1, the first pre-release version will be 0.0.1.1.

The pre-release version is updated and uploaded to your test subreddit every time you save your app code. You‚Äôll need to refresh your subreddit to see the updated app. This may take a couple of seconds, so be patient.

## Simulate purchases

In your test subreddit, you can make simulated purchases to test your app. No gold deducted in this state.

![Sample payment simulation](../../assets/payment_simulation.png)

To end your playtest, press CTRL + C in the terminal session where you started it.


---

# Publish Your App

:::note
The Developer Platform team reviews and approves apps and their products before products can be sold.
:::

To publish your app:

1. Run `devvit publish`.
2. Select how you want your app to appear in the Apps directory:

- **Unlisted** means that the app is only visible to you in the directory, and you can install your app on larger subreddits that you moderate.
- **Public** means that your app is visible to all users in the Apps directory and can be installed by mods and admins across Reddit.

You can change your app visibility at any time. See publishing an app for details.

### Ineligible products

Any apps or products for which you wish to enable payments must comply with our [Earn Policy](../reddit_developer_funds#terms-and-conditions) and [Devvit Guidelines](../../devvit_rules).


---

# Overview

:::note
Payments is a beta feature. As of this moment Payments will be supported in [Devvit Web](../../capabilities/devvit-web/devvit_web_overview.mdx) applications in September. Only applications built with [Devvit Blocks](../../capabilities/blocks/overview.md) can support Payments
:::

Add products to your app and get paid for what you sell. The payments plugin lets you prompt users to buy premium features that you build into your app, like in-game items, additional lives, or exclusive features into your app.

![Sample payment app screen](../../assets/payments_example.png)

## How to get paid

You‚Äôll set the price of the products in your app in Reddit [gold](https://support.reddithelp.com/hc/en-us/articles/17331548463764-What-is-gold-and-how-do-I-use-it). Users will use gold to acquire the items, and an equivalent amount of gold will accumulate in your app account.

Information about payouts is located [here](https://support.reddithelp.com/hc/en-us/articles/30641905617428-Developer-Program#h_01J8GCHXEG24ZNR5EZZ9SPN48S).

## Prerequisites

You can use the sandbox to build and test payments, but before you can publish your app and sell products, you‚Äôll need to:

- Verify you meet the [eligibility criteria](https://support.reddithelp.com/hc/en-us/articles/30641905617428-Developer-Program#h_01J8GCHXEG24ZNR5EZZ9SPN48S).
- Complete the verification process. You can start the process and check the status of your verification via your [settings page](https://developers.reddit.com/my/settings).
- Accept and comply with our [Earn Terms](https://redditinc.com/policies/earn-terms) and [Earn Policy](https://www.redditinc.com/policies/earn-policy).

All products will be reviewed by the Developer Platform team to ensure compliance with our content policy. Products are approved during the app review process after you publish your app.


---

# Manage Payments

Once your app and products have been approved, you‚Äôre ready to use Reddit‚Äôs production payments system. Real payments will be triggered automatically when invoked from approved app versions. No code changes are required.

## Check orders

Reddit keeps track of historical purchases and lets you query user purchases.

Orders are returned in reverse chronological order and can be filtered based on user, product, success state, or other attributes.

**Example**

```tsx
import { useOrders, OrderStatus } from '@devvit/payments';

export function CosmicSwordShop(context: Devvit.Context): JSX.Element {
  const { orders } = useOrders(context, {
    sku: 'cosmic_sword',
  });

  // if the user hasn‚Äôt already bought the cosmic sword
  // then show them the purchase button
  if (orders.length > 0) {
    return <text>Purchased!</text>;
  } else {
    return <button onPress={/* Trigger purchase */}>Buy Cosmic Sword</button>;
  }
}
```

## Update products

Once your app is in production, existing installations will need to be manually updated via the admin tool if you release a new version. Contact the Developer Platform team if you need to update your app installation versions.

Automatic updates will be supported in a future release.

## Issue a refund

Reddit may reverse transactions under certain circumstances, such as card disputes, policy violations, or technical issues. If there‚Äôs a problem with a digital good, a user can submit a request for a refund via [Reddit Help](https://support.reddithelp.com/hc/en-us/requests/new?ticket_form_id=29770197409428).

When a transaction is reversed for any reason, you may optionally revoke product functionality from the user by adding a `refundOrder` handler.

**Example**

```tsx
addPaymentHandler({
  fulfillOrder: async (order: Order, ctx: Context) => {
    // Snip order fulfillment
  },
  refundOrder: async (order: Order, ctx: Context) => {
    // check if the order contains an extra life
    if (order.products.some(({ sku }) => sku === GOD_MODE_SKU)) {
      // redis key for storing number of lives user has left
      const livesKey = `${ctx.userId}:lives`;

      // if so, decrement the number of lives
      await ctx.redis.incrBy(livesKey, -1);
    }
  },
});
```

## Payments help

When you enable payments, a **Get Payments Help** menu item is automatically added to the three dot menu in your app. This connects the user to [Reddit Help](https://support.reddithelp.com/hc/en-us/requests/new?ticket_form_id=29770197409428) for assistance.


---

# Add Payments

:::note
Payments is a beta feature. As of this moment Payments is still not supported in [Devvit Web](../../capabilities/devvit-web/devvit_web_overview.mdx) applications. Only applications built with [Devvit Blocks](../../capabilities/blocks/overview.md) can support Payments
:::

You can use the payments template to build your app or add payment functionality to an existing app.

To start with a template, select the payments template when you create a new project or run:

```bash
devvit new
```

To add payments functionality to an existing app, run:

```bash
npm install @devvit/payments
```

:::note
Make sure you‚Äôre on Devvit 0.11.3 or higher. See the [quickstart](https://developers.reddit.com/docs/next/quickstart) to get up and running.
:::

## Register products

Register products in the src/products.json file in your local app. To add products to your app, run the following command:

```bash
devvit products add
```

Registered products are updated every time an app is uploaded, including when you use [Devvit playtest](../../guides/tools/playtest.md).

<details>
  <summary>Click here for instructions on how to add products manually to your products.json file.</summary>
The JSON schema for the file format is available at <a href="https://developers.reddit.com/schema/products.json" target="_blank">https://developers.reddit.com/schema/products.json</a>.

Each product in the products field has the following attributes:
| **Attribute** | **Description** |
| ------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `sku` | A product identifier that can be used to group orders or organize your products. Each sku must be unique for each product in your app. |
| `displayName` | The official name of the product that is displayed in purchase confirmation screens. The name must be fewer than 50 characters, including spaces. |
| `description` | A text string that describes the product and is displayed in purchase confirmation screens. The description must be fewer than 150 characters, including spaces. |
| `price` | An predefined integer that sets the product price in Reddit gold. See details below. |
| `image.icon` | **(optional)** The path to the icon that represents your product in your assets folder. |
| `metadata` | **(optional)** An optional object that contains additional attributes you want to use to group and filter products. Keys and values must be alphanumeric (a - Z, 0 - 9, and - ) and contain 30 characters or less. You can add up to 10 metadata keys. Metadata keys cannot start with "devvit-". |
| `accountingType` | Categories for how buyers consume your products. Possible values are: <ul><li>`INSTANT` for purchased items that are used immediately and disappear.</li><li>`DURABLE` for purchased items that are permanently applied to the account and can be used any number of times</li><li>`CONSUMABLE` for items that can be used at a later date but are removed once they are used.</li><li>`VALID_FOR_` values indicate a product can be used throughout a period of time after it is purchased.</li></ul> |

</details>

## Price products

Product prices are predefined and must be one of the following gold values:

- 5 gold ($0.10)
- 25 gold ($0.50)
- 50 gold ($1)
- 100 gold ($2)
- 150 gold ($3)
- 250 gold ($5)
- 500 gold ($10)
- 1000 gold ($20)
- 2500 gold ($50)

:::note
Actual payments will not be processed until your products are approved. While your app is under development, you can use sandbox payments to [simulate purchases](./payments_test#simulate-purchases).
:::

## Design guidelines

You‚Äôll need to clearly identify paid products or services. Here are some best practices to follow:

- Use a short name, description, and image for each product.
- Don‚Äôt overwhelm users with too many items.
- Try to keep purchases in a consistent location or use a consistent visual pattern.
- Only use the gold icon to indicate purchases for Reddit gold.

### Product image

Product images need to meet the following requirements:

- Minimum size: 256x256
- Supported file type: .png

If you don‚Äôt provide an image, the default Reddit product image is used.

![default image](../../assets/default_product_image.png)

**Example**

```json
{
  "$schema": "https://developers.reddit.com/schema/products.json",
  "products": [
    {
      "sku": "god_mode",
      "displayName": "God mode",
      "description": "God mode gives you superpowers (in theory)",
      "price": 25,
      "images": {
        "icon": "products/extra_life_icon.png"
      },
      "metadata": {
        "category": "powerup"
      },
      "accountingType": "CONSUMABLE"
    }
  ]
}
```

### Purchase buttons (required)

#### Blocks

The `ProductButton` is a Devvit blocks component designed to render a product with a purchase button. It can be customized to match your app's look and feel.

**Usage:**

```tsx
<ProductButton
  showIcon
  product={product}
  onPress={(p) => payments.purchase(p.sku)}
  appearance="tile"
/>
```

##### `ProductButtonProps`

| **Prop Name**      | **Type**                                        | **Description**                                                                      |
| ------------------ | ----------------------------------------------- | ------------------------------------------------------------------------------------ |
| `product`          | `Product`                                       | The product object containing details such as `sku`, `price`, and `metadata`.        |
| `onPress`          | `(product: Product) => void`                    | Callback function triggered when the button is pressed.                              |
| `showIcon`         | `boolean`                                       | Determines whether the product icon is displayed on the button. Defaults to `false`. |
| `appearance`       | `'compact'` &#124; `'detailed'` &#124; `'tile'` | Defines the visual style of the button. Defaults to `compact`.                       |
| `buttonAppearance` | `string`                                        | Optional [button appearance](../../blocks/button.mdx#appearance).                    |
| `textColor`        | `string`                                        | Optional [text color](../../blocks/text.mdx#color).                                  |

#### Webviews

Use Reddit‚Äôs primary, secondary, or bordered button component and gold icon in one of the following formats:

![default image](../../assets/payments_button_purchase.png)

Use a consistent and clear product component to display paid goods or services to your users. Product components can be customized to fit your app, like the examples below.

![default image](../../assets/payments_component_button.png)

![default image](../../assets/payments_component_list.png)

![default image](../../assets/payments_component_tile.png)

## Complete the payment flow

Use `addPaymentHandler` to specify the function that is called during the order flow. This customizes how your app fulfills product orders and provides the ability for you to reject an order.

Errors thrown within the payment handler automatically reject the order. To provide a custom error message to the frontend of your application, you can return {success: false, reason: <string>} with a reason for the order rejection.

This example shows how to issue an "extra life" to a user when they purchase the "extra_life" product.

```ts
import { type Context } from '@devvit/public-api';
import { addPaymentHandler } from '@devvit/payments';
import { Devvit, useState } from '@devvit/public-api';

Devvit.configure({
  redis: true,
  redditAPI: true,
});

const GOD_MODE_SKU = 'god_mode';

addPaymentHandler({
  fulfillOrder: async (order, ctx) => {
    if (!order.products.some(({ sku }) => sku === GOD_MODE_SKU)) {
      throw new Error('Unable to fulfill order: sku not found');
    }
    if (order.status !== 'PAID') {
      throw new Error('Becoming a god has a cost (in Reddit Gold)');
    }

    const redisKey = godModeRedisKey(ctx.postId, ctx.userId);
    await ctx.redis.set(redisKey, 'true');
  },
});
```

## Implement payments

The frontend and backend of your app coordinate order processing.

![Order workflow diagram](../../assets/payments_order_flow_diagram.png)

To launch the payment flow, create a hook with `usePayments()` followed by `hook.purchase()` to initiate the purchase from the frontend.

This triggers a native payment flow on all platforms (web, iOS, Android) that works with the Reddit backend to process the order. The `fulfillOrder()` hook calls your app during this process.

Your app can acknowledge or reject the order. For example, for goods with limited quantities, your app may reject an order once the product is sold out.

### Get your product details

Use the `useProducts` hook or `getProducts` function to fetch details about products.

```tsx
import { useProducts } from '@devvit/payments';

export function ProductsList(context: Devvit.Context): JSX.Element {
  // Only query for products with the metadata "category" of value "powerup".
  // The metadata field can be empty - if it is, useProducts will not filter on metadata.
  const { products } = useProducts(context, {
    metadata: {
      category: 'powerup',
    },
  });

  return (
    <vstack>
      {products.map((product) => (
        <hstack>
          <text>{product.name}</text>
          <text>{product.price}</text>
        </hstack>
      ))}
    </vstack>
  );
}
```

You can also fetch all products using custom-defined metadata or by an array of skus. Only one is required; if you provide both then they will be AND‚Äôd.

```tsx
import { getProducts } from '@devvit/payments';
const products = await getProducts({,
});
```

### Initiate orders

Provide the product sku to trigger a purchase. This automatically populates the most recently-approved product metadata for that product id.

**Example**

```tsx
import { usePayments } from '@devvit/payments';

// handles purchase results
const payments = usePayments((result: OnPurchaseResult) => { console.log('Tried to buy:', result.sku, '; result:', result.status); });

// for each sku in products:
<button onPress{payments.purchase(sku)}>Buy a {sku}</button>
```


---

# Realtime in Devvit Blocks

This guide walks through step-by-step instructions on how to set up [Realtime](./overview.md) in a [Devvit Blocks](../blocks/overview.md) application

## Create a live interactive post

#### 1. Configure realtime

```tsx
Devvit.configure({
  realtime: true,
});
```

#### 2. Create and subscribe to a channel

`useChannel` hook allows interactive posts to subscribe and send to an event stream.

A new channel can be setup with function handlers containing custom logic to update state:

- `onMessage` - called every time a message is received on a channel
- `onSubscribed` - optional hook to be informed when channel has connected
- `onUnsubscribed` - optional hook to be informed when channel has disconnected

```tsx
import { Devvit, useChannel } from '@devvit/public-api';

// Defined within render function of an interactive post

// Choose a channel name that works for you

// You have the flexibility to define the message data shape to be published
// via channel.send - same shape will be received in the onMessage handler

const channel = useChannel({
  name: 'events',
  onMessage: (data) => {
    // modify local state
  },
  onSubscribed: () => {
    // handle connection setup
  },
  onUnsubscribed: () => {
    // handle network degradation with fallback scenarios
  },
});

// subscribe to the channel to receive messages
channel.subscribe();
```

#### 3. Send messages to a channel

`channel.send` is recommended for peer-to-peer synchronization across clients. See [Mini Place](#mini-place) and [Snoo Club](#snoo-club)

```tsx
<button
  icon="add-fill"
  width={50}
  onPress={async () => {
    const newProgress = Math.max(progress + 10, 0);
    const message: RealtimeMessage = {
      payload: { progress: newProgress },
      session: UUID,
    };
    setProgress(newProgress); // set local state
    await channel.send(message); // publish message to the channel
  }}
/>
```

`realtime.send` is recommended for re-rendering interactive posts based on server events. This can be invoked on an event trigger, scheduled job, or after a HTTP fetch call. [Server-Push](#server-push) example illustrates how to compose scheduler and realtime together.

```tsx
// During app installation, we create a scheduled job 'publish_to_channel' that runs
// every minute - it uses realtime plugin to publish events to an arbitrary channel

Devvit.addTrigger({
  event: 'AppInstall',
  onEvent: async (_event, context) => {
    await context.scheduler.runJob({
      name: 'publish_to_channel',
      cron: '* * * * *',
    });
  },
});

// Interactive posts subscribed to the 'events' channel via useChannel hook will start
// receiving messages which can processed in the onMessage handler to update local state.
Devvit.addSchedulerJob({
  name: 'publish_to_channel',
  onRun: async (_event, context) => {
    await context.realtime.send('events', {
      message: payload,
    });
  },
});
```

## Limits and quotas

- Messages/sec per installation: 100
- Maximum message payload: 1 MB
- Channels per app installation: 5

## Examples

:::note
Try the demos with multiple browser windows and see local changes sync across sessions without any lag.
:::

### Mini place

![mini_place_high](../../assets/realtime/mini_place_high.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bumd7e/mini_place/)**,
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/mini-place)**

### Snoo club

![snoo_club](../../assets/realtime/snoo_club.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bunpzv/interactive_snooclub/)**,
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/snooclub)**

### Synced progress bar

![synced_progress_bar](../../assets/realtime/synced_progress_bar.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1b3ccp9/synced_progress_bar/),**
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/synced-progress-bar)**

### Devvit emoji chat

![devvit_emoji_chat](../../assets/realtime/devvit_emoji_chat.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bvf6if/emoji_chat/),**
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/devvit-emoji-chat)**

### Server push

![server_push](../../assets/realtime/server_push.gif)

**[Demo](https://sh.reddit.com/r/devvit_sandbox/comments/1bnnc60/server_push/),**
**[Source Code](https://github.com/reddit/devvit/tree/main/packages/apps/server-push)**


---

# Overview

Create live and event-driven interactive posts. Realtime provides a set of primitives that lets you build interactive posts that are:

- **Live**. Users engaging with the same interactive post see each others‚Äô changes without any observable lag.
- **Event-driven**. Posts render automatically in response to server events.
- **Synced**. Using realtime with [Redis](../server/redis.mdx) lets you build persistent community experiences that are backed by high performance data synchronization.

Realtime is supported in both [Devvit Web](../devvit-web/devvit_web_overview.mdx) and [Devvit Blocks](../blocks/overview.md) applications.

Follow this guide, [Realtime in Devvit Blocks](./realtime_in_devvit_blocks.md), for instructions on using realtime in Devvit Blocks.

# Realtime in Devvit Web

This guide walks through step-by-step instructions on how to set up [Realtime](./overview.md) in a [Devvit Web](../devvit-web/devvit_web_overview.mdx) application

## Overview

The realtime client allows you to:

- **Connect** to realtime channels for receiving messages
- **Handle** connection lifecycle events (connect/disconnect)
- **Process** incoming messages with custom logic
- **Manage** multiple channel subscriptions
- **Disconnect** from channels when no longer needed

## Architecture

Realtime functionality in Devvit follows a client/server architecture:

- **Client-side** (connectRealtime): Subscribe to channels and receive messages
- **Server-side** (realtime.send): Send messages to channels

This separation ensures that message sending is controlled by server-side logic while clients can freely subscribe to channels they're interested in.

## Client-side API reference

### connectRealtime

Connects to a realtime channel for receiving messages.

```tsx
import { connectRealtime } from '@devvit/web/client';

const connection = await connectRealtime({
  channel: 'my-channel',
  onConnect: (channel) => {
    console.log(`Connected to ${channel}`);
  },
  onDisconnect: (channel) => {
    console.log(`Disconnected from ${channel}`);
  },
  onMessage: (data) => {
    console.log('Received message:', data);
  },
});
```

#### Parameters

- `opts` - Connection options object
  - `channel` (string) - The name of the channel to connect to
  - `onConnect?` (function) - Optional callback called when connection is established
  - `onDisconnect?` (function) - Optional callback called when connection is lost
  - `onMessage` (function) - Required callback called when a message is received

#### Returns

A `Connection` object with a `disconnect()` method.

### Connection

A connection object returned by `connectRealtime()`.

#### Methods

##### disconnect()

Disconnects from the realtime channel.

```tsx
await connection.disconnect();
```

This method:

- Removes the channel from active subscriptions
- Cleans up event listeners
- Calls the `onDisconnect` callback if provided

## Server-side API reference

### Realtime plugin

The server-side plugin for sending messages to realtime channels.

```tsx
import { realtime } from '@devvit/web/server';

// Send a message to a channel
await realtime.send('my-channel', {
  type: 'user-joined',
  userId: '123',
});
```

#### Methods

##### send(channel: string, msg: JSONValue): Promise<void>

Sends a message to a specific channel.

- `channel` (string) - The name of the channel to send the message to
- `msg` (JSONValue) - The message data to send

## Usage examples

### Client-side: basic channel connection

```tsx
import { connectRealtime } from '@devvit/web/client';

// Connect to a channel
const connection = await connectRealtime({
  channel: 'user-updates',
  onMessage: (data) => {
    // Handle incoming messages
    console.log('User update:', data);
  },
});

// Later, disconnect when done
await connection.disconnect();
```

### Client-side: connection lifecycle management

```tsx
import { connectRealtime } from '@devvit/web/client';

const connection = await connectRealtime({
  channel: 'live-chat',
  onConnect: (channel) => {
    console.log(`Connected to ${channel}`);
    // Update UI to show connected state
    setIsConnected(true);
  },
  onDisconnect: (channel) => {
    console.log(`Disconnected from ${channel}`);
    // Update UI to show disconnected state
    setIsConnected(false);
  },
  onMessage: (data) => {
    // Process chat messages
    addMessageToChat(data);
  },
});
```

### Server-side: sending messages

```tsx
import { realtime } from '@devvit/web/server';

// Send a simple message
await realtime.send('notifications', 'New user joined!');

// Send a structured message
await realtime.send('game-updates', {
  type: 'score-update',
  playerId: 'user123',
  score: 1500,
  timestamp: Date.now(),
});
```


---

# User actions

User actions allow your app to perform certain actions‚Äîsuch as creating posts, comments, or subscribing to subreddits‚Äîon behalf of the user, rather than the app account. This enables stronger user engagement while ensuring user control and transparency.

---

## What are user actions?

By default, apps make posts or comments using their associated app account. With user actions enabled, your app can:

- Create posts or comments on behalf of the user (from the post UI, a form, or a menu action)
- Subscribe the user to the current subreddit

---

## Guidelines

To ensure a positive user experience and compliance with Reddit policies:

- **Be transparent:** Inform users and show them the content that will be posted on their behalf.
- **Provide user control:** Users must opt in to allow the app to post on their behalf. If opt-in is persistent, make it clear how users can opt out.

:::note
Apps using user actions must follow these guidelines to be approved.
:::

---

## How it works

- **Unapproved/playtest apps:**
  - `runAs: 'USER'` will operate from the app account unless the app owner takes the action.
  - User actions taken by the app owner will be attributed to the app owner's username.
- **Approved apps:**
  - After publishing and approval, `runAs: 'USER'` will operate on behalf of the user for all users.

---

## Enabling user actions

To enable user actions, add the required permissions to your `devvit.json`:

```json title="devvit.json"
"reddit": {
  "asUser": [
    "SUBMIT_POST",
    "SUBMIT_COMMENT",
    "SUBSCRIBE_TO_SUBREDDIT"
  ]
}
```

After enabling, you can call certain Reddit APIs on behalf of the user by passing the option `runAs: 'USER'`.

Currently, the following APIs support this option:

- [submitPost()](../../api/redditapi/RedditAPIClient/classes/RedditAPIClient.md#submitpost)
- [submitComment()](../../api/redditapi/RedditAPIClient/classes/RedditAPIClient.md#submitcomment)

If `runAs` is not specified, the API will use `runAs: 'APP'` by default.

---

## Parameters

| Parameter              | Description                                                                                                              |
| ---------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `runAs`                | The type of account to perform the action on behalf of: `'USER'` or `'APP'`. Defaults to `'APP'`.                        |
| `userGeneratedContent` | Text or images submitted by the user. Required for `submitPost()` with `runAs: 'USER'` for safety and compliance review. |

:::note
Apps that use `submitPost()` with `runAs: 'USER'` require `userGeneratedContent` to be approved by Reddit.
:::

---

## Example: Submit a post as the user

This example uses a form to prompt the user for input and then submits a post as the user.

```tsx
import { reddit } from '@devvit/web/server';

// ...

router.post('/internal/post-create', async (_req, res) => {
  const { subredditName } = context;
  if (!subredditName) {
    res.status(400).json({ status: 'error', message: 'subredditName is required' });
    return;
  }

  reddit.submitPost({
    runAs: 'USER',
    userGeneratedContent: {
      text: "Hello there! This is a new post from the user's account",
    },
    subredditName,
    title: 'Post Title'
    splash: { appDisplayName: 'Test App' }
  });

  res.json({ status: 'success', message: `Post created in subreddit ${subredditName}` });
});
```

---

## Example: Subscribe to subreddit

The subscribe API does not take a `runAs` parameter; it subscribes as the user by default (if specified in `devvit.json` and approved).

```ts
import { reddit } from '@devvit/web/server';

await reddit.subscribeToCurrentSubreddit();
```

:::note
There is no API to check if the user is already subscribed to the subreddit. You may want to store the subscription state in Redis to provide contextually aware UI.
:::

---

## Best practices

- Always inform users before posting or commenting on their behalf.
- Require explicit user opt-in for all user actions.
- Use `userGeneratedContent` for all user-submitted posts.
- Store user consent and subscription state if needed for your app's UX.
- Follow Reddit's safety and compliance guidelines for user-generated content.


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Triggers

Triggers allow your app to automatically respond to specific events or actions within a Reddit community. Use triggers to build automation, moderation, and engagement features that react to user or moderator activity.

## What are triggers?

A trigger is an action you can build into your app that will occur automatically when a specified condition is met. For example, you can set up a trigger to respond when a new post is submitted, a comment is created, or a moderator takes action.

## Supported trigger types

Event triggers let your app automatically respond to a user's or moderator's action. The following trigger types are supported:

- `onPostSubmit`
- `onPostCreate`
- `onPostUpdate`
- `onPostReport`
- `onPostDelete`
- `onPostFlairUpdate`
- `onCommentCreate`
- `onCommentDelete`
- `onCommentReport`
- `onCommentSubmit`
- `onCommentUpdate`
- `onPostNsfwUpdate`
- `onPostSpoilerUpdate`
- `onAppInstall`
- `onAppUpgrade`
- `onModActions`
- `onModMail`
- `onAutomoderatorFilterPost`
- `onAutomoderatorFilterComment`

A full list of events and their payloads can be found in the [EventTypes documentation](../../api/public-api/@devvit/namespaces/EventTypes/). For more details on Mod specific actions, see [ModActions](../../api/redditapi/models/interfaces/ModAction) and [ModMail](../../api/public-api/type-aliases/ModMailDefinition).

## Setting up triggers

### 1. Add triggers and endpoints to `devvit.json`

<Tabs>
  <TabItem value="web" label="Devvit Web">
  Declare the triggers and their corresponding endpoints in your `devvit.json`:

  ```json
  "triggers": {
    "onAppUpgrade": "/internal/on-app-upgrade",
    "onCommentCreate": "/internal/on-comment-create",
    "onPostSubmit": "/internal/on-post-submit"
  }
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  Declare the triggers in your `devvit.json`:

  ```json
  {
    "name": "your-app-name",
    "blocks": {
      "entry": "src/main.tsx",
      "triggers": ["onPostCreate"]
    }
  }
  ```
  </TabItem>
</Tabs>

### 2. Handle trigger events in your server logic

<Tabs>
  <TabItem value="web" label="Devvit Web">
  Listen for the events in your server and access the data passed into the request. Example (`server/index.ts`):

  ```ts
  const router = express.Router();

  // ..

  router.post('/internal/on-app-upgrade', async (req, res) => {
    console.log(`Handle event for on-app-upgrade!`);
    const installer = req.body.installer;
    console.log('Installer:', JSON.stringify(installer, null, 2));
    res.status(200).json({ status: 'ok' });
  });

  router.post('/internal/on-comment-create', async (req, res) => {
    console.log(`Handle event for on-comment-create!`);
    const comment = req.body.comment;
    const author = req.body.author;
    console.log('Comment:', JSON.stringify(comment, null, 2));
    console.log('Author:', JSON.stringify(author, null, 2));
    res.status(200).json({ status: 'ok' });
  });

  router.post('/internal/on-post-submit', async (req, res) => {
    console.log(`Handle event for on-post-submit!`);
    const post = req.body.post;
    const author = req.body.author;
    console.log('Post:', JSON.stringify(post, null, 2));
    console.log('Author:', JSON.stringify(author, null, 2));
    res.status(200).json({ status: 'ok' });
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  Handle trigger events in your main file. Example (`src/main.tsx`):

  ```tsx
  import { Devvit } from '@devvit/public-api';

  // Handling a PostSubmit event
  Devvit.addTrigger({
    event: 'PostSubmit', // Event name from above
    onEvent: async (event) => {
      console.log(`Received OnPostSubmit event:\n${JSON.stringify(event)}`);
    },
  });

  // Handling multiple events: PostUpdate and PostReport
  Devvit.addTrigger({
    events: ['PostUpdate', 'PostReport'], // An array of events
    onEvent: async (event) => {
      if (event.type == 'PostUpdate') {
        console.log(`Received OnPostUpdate event:\n${JSON.stringify(request)}`);
      } else if (event.type === 'PostReport') {
        console.log(`Received OnPostReport event:\n${JSON.stringify(request)}`);
      }
    },
  });

  export default Devvit;
  ```
  </TabItem>
</Tabs>

## Best practices

- Avoid creating recursive triggers that could cause infinite loops or crashes (for example, a comment trigger that creates a comment).
- Always check the event payload to ensure your app is not the source of the event before taking action.
- Review the [EventTypes documentation](../../api/public-api/@devvit/namespaces/EventTypes/) for details on event payloads.


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Text Fallback for old.reddit

Old.reddit does not render interactive posts. To remedy this, use textFallback to ensure that you can specify the text for the instances when Devvit cannot render your post. You can do this with a text string or in rich text.

Setting a relevant text fallback is critical for SEO and growth of your app.

## [Reddit API](./reddit-api.mdx)
The text fallback is only available when using the Reddit API to create a post. It is available for both [Devvit Web](../devvit-web/devvit_web_overview.mdx) and [Devvit Blocks](../blocks/overview.md) applications. 
The code samples below assume that you already have a reference to the Reddit API client. Please see below how to obtain a refere
nce to the Reddit API client in both Devvit Web and Devvit Blocks.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```json title="devvit.json"
  {
    "permissions": {
      "redditApi": true
    }
  }
  ```

  ```ts title="server/index.ts"
  import { reddit } from '@devvit/web/server';
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts
  import { Devvit } from '@devvit/public-api';

  Devvit.configure({
    redditApi: true,
  });

  //Then, in any function that has a reference to Devvit.Context:
  const reddit = context.reddit;
  ```
  </TabItem>
</Tabs>

## Use a text string

```tsx
import { reddit } from '@devvit/web/server';

const post = await reddit.submitCustomPost({
  title: 'Text String',
  subredditName: subreddit.name,
  textFallback: { text: 'You can read this text string on oldreddit because you used textFallback' },
  splash: { appDisplayName: 'Test App' },
});
```

**Result**

![text string fallback](../../assets/fallback_text_string.png)

## Use a text string with markdown

```tsx
import { reddit } from '@devvit/web/server';

const post = await reddit.submitCustomPost({
  title: 'Text string with markdown',
  subredditName: subreddit.name,
  textFallback: {
    text: 'You can read this _text string with markdown_ on oldreddit because you used **textFallback**',
  },
  splash: { appDisplayName: 'Test App' },
});
```

**Result**

![text string fallback](../../assets/fallback_markdown.png)

## Use rich text

```tsx
import { reddit } from '@devvit/web/server';

const textFallbackRichtext = new RichTextBuilder()
  .heading({ level: 1 }, (h) => {
    h.rawText('Yay for text fallbacks!');
  })
  .codeBlock({}, (cb) => cb.rawText('You can read this rich text on old.reddit because you used textFallback'));

const post = await reddit.submitCustomPost({
  title: 'Rich Text',
  subredditName: subreddit.name,
  textFallback: { richtext: textFallbackRichtext },
  splash: { appDisplayName: 'Test App' },
});
```

**Result**

![text string fallback](../../assets/fallback_richtext.png)

## Update a post‚Äôs text fallback

The post author can edit and update text fallback content after it‚Äôs been created. To do this, call post.setTextFallback with the desired fallback content.

```tsx
import { reddit } from '@devvit/web/server';

// from a menu action, form, scheduler, trigger, custom post click event, etc
const newTextFallback = { text: 'This is an updated text fallback' };
const post = await reddit.getPostById(context.postId);
await post.setTextFallback(newTextFallback);
```


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Splash Screens

Splash screens provide a personalized entry point for your Reddit Dev Platform apps, displaying a customized loading view before users interact with your post. A well-designed splash screen improves first impressions and drives better user engagement.

The splash screen appears when users first view your post, featuring your app's branding, a description, and a call-to-action button that launches the main experience.

![Splash Screen](../../assets/splash_screen.png)

:::note
Splash screens are only available for web view apps on Devvit Web.
:::

## Creating posts with splash screens

When creating a post, include the `splash` parameter to customize the splash screen appearance.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts title="server/index.ts"
  import { reddit } from '@devvit/web/server';

  const post = await reddit.submitCustomPost({
    subredditName: context.subredditName!,
    title: 'My Interactive Post',
    splash: {
      appDisplayName: 'My Amazing App', // only required field
      backgroundUri: 'background.png',
      buttonLabel: 'Start Playing',
      description: 'An exciting interactive experience',
      entryUri: 'index.html',
      heading: 'Welcome to the Game!'
    },
    postData: {
      gameState: 'initial',
      score: 0
    }
  });
  ```
  </TabItem>
</Tabs>

## Splash screen properties

The `splash` object supports the following customization options:

| Property | Type | Description | Default |
|----------|------|-------------|---------|
| `appDisplayName` | string | Your app's display name | Required |
| `backgroundUri` | string | Background image URL (relative to media directory or data URI) | None |
| `buttonLabel` | string | Text for the launch button | `'Launch App'` |
| `description` | string | Secondary text describing the post experience | None |
| `entryUri` | string | Web view URI relative to client directory | `'index.html'` |
| `heading` | string | Large text naming the post under app name | `appDisplayName` |
| `appIconUri` | string | Icon URL relative to media directory or data URI | None |

### Using images

Images can be referenced in two ways:

1. **Local assets**: Place images in your app's assets directory and reference them by filename:
    For example, if your image is in `assets/splash-background.png`, then you can just reference it with `splash-background.png`
    
    :::note
    If you put the images in a different directory, you can configure that by adding the `media` property to your `devvit.json` file. Set `media.dir` to the directory path you are using.
    :::
    For example, if you are putting the image in `assets/images`, then you can write it like this: 
   ```json title="devvit.json"
   "media": {
     "dir": "assets/images"
   }
   ```

    And you can reference them by their filename

    ```ts title="server/index.ts"
    backgroundUri: '/splash-background.png'
    appIconUri: '/app-icon.png'
    ```
    Without configuring `media.dir`, you have to reference the images relative to the `assets` directory, which would be `images/splash-background.png` in this example

   

2. **External URLs**: Use full HTTPS URLs for hosted images:
   ```ts
   backgroundUri: 'https://i.redd.it/your-image.png'
   ```

## Example: Dynamic splash screens

You can create different splash screens based on context or user preferences:

```ts title="server/index.ts"
import { reddit } from '@devvit/web/server';

async function createThemedPost(theme: 'light' | 'dark', context: any) {
  const themes = {
    light: {
      backgroundUri: 'light-bg.png',
      heading: 'Bright Adventure',
      description: 'A cheerful experience awaits'
    },
    dark: {
      backgroundUri: 'dark-bg.png', 
      heading: 'Night Mode Quest',
      description: 'Explore the shadows'
    }
  };

  const selectedTheme = themes[theme];
  
  return await reddit.submitCustomPost({
    subredditName: context.subredditName!,
    title: `${selectedTheme.heading} - Interactive Post`,
    splash: {
      appDisplayName: 'Theme Explorer',
      backgroundUri: selectedTheme.backgroundUri,
      buttonLabel: 'Begin Journey',
      description: selectedTheme.description,
      entryUri: 'game.html',
      heading: selectedTheme.heading
    },
    postData: {
      theme: theme,
      initialized: false
    }
  });
}
```

## Best practices

- **Keep it lightweight**: Use optimized images to ensure fast loading times
- **Clear call-to-action**: Make your button label descriptive and action-oriented
- **Consistent branding**: Use your app icon and consistent visual elements
- **Informative description**: Tell users what to expect when they launch your app

## Limitations

- Image files must be included in your app bundle or hosted externally
- Maximum recommended image size: 2MB for optimal performance
- The `entryUri` must point to a valid HTML file in your client directory

:::tip
A compelling splash screen is your app's first impression. Invest time in creating an engaging design that clearly communicates your app's value and encourages users to interact.
:::


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Settings and Secrets

Configure your app with settings that can be customized per subreddit or globally across all installations. Settings allow moderators to customize app behavior for their subreddit, while secrets enable secure storage of sensitive data like API keys.

Settings come in two scopes:
- **Subreddit settings**: Configurable by moderators for each installation
- **Global settings & Secrets**: Set by developers and shared across all installations

## Defining settings

Settings are defined differently depending on whether you're using Devvit Web or Devvit Blocks.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  Define settings in your `devvit.json` file under the `settings` object. Settings are organized by scope: `global` for app-wide settings and secrets, `subreddit` for installation-specific settings.

  ```json title="devvit.json"
  {
    "settings": {
      "global": {
        "apiKey": {
          "type": "string",
          "label": "API Key",
          "defaultValue": "",
          "isSecret": true
        },
        "environment": {
          "type": "select",
          "label": "Environment",
          "options": [
            {
              "label": "Production",
              "value": "production"
            },
            {
              "label": "Development",
              "value": "development"
            }
          ],
          "defaultValue": "production"
        }
      },
      "subreddit": {
        "welcomeMessage": {
          "type": "string",
          "label": "Welcome Message",
          "validationEndpoint": "/internal/settings/validate-message",
          "defaultValue": "Welcome to our community!"
        },
        "enabledFeatures": {
          "type": "multiSelect",
          "label": "Enabled Features",
          "options": [
            {
              "label": "Auto-moderation",
              "value": "automod"
            },
            {
              "label": "Welcome posts",
              "value": "welcome"
            },
            {
              "label": "Statistics tracking",
              "value": "stats"
            }
          ],
          "defaultValue": ["welcome"]
        }
      }
    }
  }
  ```

  :::note
  After defining settings in `devvit.json`, you must build your app (`npm run dev`) before you can set secrets via the CLI.
  :::
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  Use `Devvit.addSettings` to define settings with the appropriate scope.

  ```tsx title="main.tsx"
  import { Devvit, SettingScope } from '@devvit/public-api';

  Devvit.addSettings([
    // Global secret
    {
      type: 'string',
      name: 'apiKey',
      label: 'API Key',
      isSecret: true,
      scope: SettingScope.App, // or 'app'
    },
    // Global setting
    {
      type: 'select',
      name: 'environment',
      label: 'Environment',
      options: [
        { label: 'Production', value: 'production' },
        { label: 'Development', value: 'development' },
      ],
      scope: 'app',
    },
    // Subreddit setting
    {
      type: 'string',
      name: 'welcomeMessage',
      label: 'Welcome Message',
      scope: SettingScope.Installation, // or 'installation'
      onValidate: async ({ value }) => {
        if (!value || value.length < 5) {
          return 'Message must be at least 5 characters';
        }
      },
    },
    // Subreddit multi-select
    {
      type: 'select',
      name: 'enabledFeatures',
      label: 'Enabled Features',
      options: [
        { label: 'Auto-moderation', value: 'automod' },
        { label: 'Welcome posts', value: 'welcome' },
        { label: 'Statistics tracking', value: 'stats' },
      ],
      multiSelect: true,
      scope: 'installation',
    },
  ]);
  ```
  </TabItem>
</Tabs>

## Setting types

Both frameworks support the following setting types:

- **string**: Text input field
- **boolean**: Toggle switch
- **number**: Numeric input
- **select**: Dropdown selection (single choice)
- **multiSelect** (Web) / **select with multiSelect: true** (Blocks): Multiple choice dropdown
- **paragraph**: Multi-line text input (Blocks only)
- **group**: Grouped settings for organization (Blocks only)

## Managing secrets

Secrets are global settings marked with `isSecret: true`. They're encrypted and can only be set by developers via the CLI.

### Listing secrets

View all defined secrets in your app:

```bash
npx devvit settings list

Key          Label         Is this a secret?   Type
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ   ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
apiKey       API Key       true                STRING
environment  Environment   false               SELECT
```

### Setting secret values

Only app developers can set secret values:

```bash
npx devvit settings set apiKey

? Enter the value you would like to assign to the variable apiKey: <value>

Updating app settings... ‚úÖ
Successfully added app settings for apiKey!
```

:::warning
At least one app installation is required before you can store secrets via the CLI. You can run `npx devvit playtest` (or `npm run dev` in Devvit Web) to start your first installation.
:::

## Accessing settings in your app

Settings can be retrieved from within your app.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```tsx title="server/index.ts"
  import { settings } from '@devvit/web/server';

  // Get a single setting
  const apiKey = await settings.get('apiKey');
  
  // Get multiple settings
  const [welcomeMessage, features] = await Promise.all([
    settings.get('welcomeMessage'),
    settings.get('enabledFeatures')
  ]);

  // Use in an endpoint
  router.post('/api/process', async (req, res) => {
    const apiKey = await settings.get('apiKey');
    const environment = await settings.get('environment');
    
    const response = await fetch('https://api.example.com/endpoint', {
      headers: {
        'Authorization': `Bearer ${apiKey}`,
        'X-Environment': environment
      }
    });
    
    res.json({ success: true });
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  ```tsx title="main.tsx"
  import { Devvit } from '@devvit/public-api';

  Devvit.addMenuItem({
    label: 'Process with API',
    location: 'subreddit',
    onPress: async (_event, context) => {
      // Get individual settings
      const apiKey = await context.settings.get('apiKey');
      const welcomeMessage = await context.settings.get('welcomeMessage');
      
      // Get all settings
      const allSettings = await context.settings.getAll();
      
      // Use the settings
      const response = await fetch('https://api.example.com/endpoint', {
        headers: {
          'Authorization': `Bearer ${apiKey}`,
        }
      });
      
      context.ui.showToast(`Processed with message: ${welcomeMessage}`);
    },
  });

  // Access in custom post type
  Devvit.addCustomPostType({
    name: 'ConfigurablePost',
    render: (context) => {
      const [features, setFeatures] = useState<string[]>([]);
      
      useEffect(async () => {
        const enabledFeatures = await context.settings.get('enabledFeatures');
        setFeatures(enabledFeatures || []);
      }, []);
      
      return (
        <vstack>
          <text>Enabled features: {features.join(', ')}</text>
        </vstack>
      );
    },
  });
  ```
  </TabItem>
</Tabs>

## Input validation

Validate user input to ensure it meets your requirements before saving.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  Define a validation endpoint in your `devvit.json` and implement it in your server:

  ```json title="devvit.json"
  {
    "settings": {
      "subreddit": {
        "minimumAge": {
          "type": "number",
          "label": "Minimum Account Age (days)",
          "validationEndpoint": "/internal/settings/validate-age",
          "defaultValue": 7
        }
      }
    }
  }
  ```

  ```tsx title="server/index.ts"
  import { SettingsValidationRequest, SettingsValidationResponse } from '@devvit/web/server';

  router.post(
    '/internal/settings/validate-age',
    async (
      req: Request<unknown, unknown, SettingsValidationRequest<number>>,
      res: Response<SettingsValidationResponse>
    ): Promise<void> => {
      const { value } = req.body;

      if (!value || value < 0) {
        res.json({
          success: false,
          error: 'Age must be a positive number',
        });
        return;
      }

      if (value > 365) {
        res.json({
          success: false,
          error: 'Maximum age is 365 days',
        });
        return;
      }

      res.json({ success: true });
    }
  );
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  Add an `onValidate` handler to your setting definition:

  ```tsx title="main.tsx"
  Devvit.addSettings([
    {
      type: 'number',
      name: 'minimumAge',
      label: 'Minimum Account Age (days)',
      scope: 'installation',
      onValidate: async ({ value }) => {
        if (!value || value < 0) {
          return 'Age must be a positive number';
        }
        if (value > 365) {
          return 'Maximum age is 365 days';
        }
      },
    },
  ]);
  ```
  </TabItem>
</Tabs>

## Subreddit settings UI

Once your app is installed, moderators can configure subreddit settings through the Install Settings page. These settings are scoped to the specific subreddit where the app is installed.

<!-- ![Settings configuration interface](../assets/capabilities/app-configurations/app-configurations-all-types.png) -->

Moderators will see all non-secret settings defined for the subreddit scope and can update them as needed. Changes are saved immediately and available to your app.

## Complete example

Here's a complete example showing both secrets and subreddit settings in action:

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```json title="devvit.json"
  {
    "settings": {
      "global": {
        "openaiApiKey": {
          "type": "string",
          "label": "OpenAI API Key",
          "isSecret": true,
          "defaultValue": ""
        }
      },
      "subreddit": {
        "aiModel": {
          "type": "select",
          "label": "AI Model",
          "options": [
            { "label": "GPT-4", "value": "gpt-4" },
            { "label": "GPT-3.5", "value": "gpt-3.5-turbo" }
          ],
          "defaultValue": "gpt-3.5-turbo"
        },
        "maxTokens": {
          "type": "number",
          "label": "Max Response Tokens",
          "validationEndpoint": "/internal/settings/validate-tokens",
          "defaultValue": 150
        }
      }
    }
  }
  ```

  ```tsx title="server/index.ts"
  import { settings } from '@devvit/web/server';

  router.post('/api/generate', async (req, res) => {
    const [apiKey, model, maxTokens] = await Promise.all([
      settings.get('openaiApiKey'),
      settings.get('aiModel'),
      settings.get('maxTokens')
    ]);

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model,
        max_tokens: maxTokens,
        messages: req.body.messages,
      }),
    });

    const data = await response.json();
    res.json(data);
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  ```tsx title="main.tsx"
  import { Devvit } from '@devvit/public-api';

  Devvit.configure({
    http: true,
  });

  Devvit.addSettings([
    {
      name: 'openaiApiKey',
      label: 'OpenAI API Key',
      type: 'string',
      isSecret: true,
      scope: 'app',
    },
    {
      name: 'aiModel',
      label: 'AI Model',
      type: 'select',
      options: [
        { label: 'GPT-4', value: 'gpt-4' },
        { label: 'GPT-3.5', value: 'gpt-3.5-turbo' },
      ],
      scope: 'installation',
    },
    {
      name: 'maxTokens',
      label: 'Max Response Tokens',
      type: 'number',
      scope: 'installation',
      onValidate: async ({ value }) => {
        if (value < 1 || value > 500) {
          return 'Tokens must be between 1 and 500';
        }
      },
    },
  ]);

  async function generateResponse(context: Devvit.Context, prompt: string): Promise<string> {
    const [apiKey, model, maxTokens] = await Promise.all([
      context.settings.get('openaiApiKey'),
      context.settings.get('aiModel'),
      context.settings.get('maxTokens'),
    ]);

    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model,
        max_tokens: maxTokens,
        messages: [{ role: 'user', content: prompt }],
      }),
    });

    const data = await response.json();
    return data.choices[0]?.message?.content || 'No response';
  }

  Devvit.addCustomPostType({
    name: 'AI Assistant',
    render: (context) => {
      const [response, setResponse] = useState('');

      return (
        <vstack gap="medium" padding="medium">
          <button 
            onPress={async () => {
              const result = await generateResponse(context, 'Hello!');
              setResponse(result);
            }}
          >
            Generate Response
          </button>
          {response && <text>{response}</text>}
        </vstack>
      );
    },
  });

  export default Devvit;
  ```
  </TabItem>
</Tabs>

## Limitations

- Secrets can only be global
- Secrets can only be set via CLI by app developers
- Setting values are currently not fully surfaced in the CLI
- Maximum of 2KB per setting value


---

# Scheduler

The scheduler allows your app to perform actions at specific times, such as sending private messages, tracking upvotes, or scheduling timeouts for user actions. You can schedule both recurring and one-off jobs using the scheduler.

---

## Scheduling recurring jobs

To create a regularly occurring event in your app, declare a task in your `devvit.json` and handle the event in your server logic.

### 1. Add a recurring task to `devvit.json`

Ensure the endpoint follows the format `/internal/.+` and specify a `cron` schedule:

```json title="devvit.json"
"scheduler": {
  "tasks": {
    "regular-interval-example-task": {
      "endpoint": "/internal/scheduler/regular-interval-task-example",
      "cron": "*/1 * * * *"
    }
  }
},
```

- The `cron` parameter uses the standard [UNIX cron format](https://en.wikipedia.org/wiki/Cron):
  ```
  # * * * * *
  # | | | | |
  # | | | | day of the week (0‚Äì6, Sunday to Saturday; 7 is also Sunday on some systems)
  # | | | month (1‚Äì12)
  # | | day of the month (1‚Äì31)
  # | hour (0‚Äì23)
  # minute (0‚Äì59)
  ```
- We recommend using [Cronitor](https://crontab.guru/) to build cron strings.

### 2. Handle the event in your server

```ts title=/server/index.ts
router.post('/internal/scheduler/regular-interval-task-example', async (req, res) => {
  console.log(`Handle event for cron example at ${new Date().toISOString()}!`);
  // Handle the event here
  res.status(200).json({ status: 'ok' });
});
```

---

## Scheduling one-off jobs at runtime

One-off tasks must also be declared in `devvit.json`.

### 1. Add the tasks to `devvit.json`

```json title='devvit.json'
"scheduler": {
  "tasks": {
    "regular-interval-task-example": {
      "endpoint": "/internal/scheduler/regular-interval-task-example",
      "cron": "*/1 * * * *"
    },
    "one-off-task-example": {
      "endpoint": "/internal/scheduler/one-off-task-example"
    }
  }
}
```

### 2. Schedule a job at runtime

Example usage:

```ts
import { scheduler } from '@devvit/web/server';

// Handle the occurrence of the event
router.post('/internal/scheduler/one-off-task-example', async (req, res) => {
  const oneMinuteFromNow = new Date(Date.now() + 1000 * 60);

  let scheduledJob: ScheduledJob = {
    id: `job-one-off-for-post${postId}`,
    name: 'one-off-task-example',
    data: { postId },
    runAt: oneMinuteFromNow,
  };

  let jobId = await scheduler.runJob(scheduledJob);
  console.log(`Scheduled job ${jobId} for post ${postId}`);
  console.log(`Handle event for one-off event at ${new Date().toISOString()}!`);
  // Handle the event here
  res.status(200).json({ status: 'ok' });
});
```

---

## Limitations

_Limits are per installation of an app:_

1. An installation can have up to **10 live recurring actions**.
2. The `runJob()` method enforces two rate limits when creating actions:
   - **Creation rate:** Up to 60 calls to `runJob()` per minute
   - **Delivery rate:** Up to 60 deliveries per minute


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Redis

You can add a database to your app to store and retrieve data. The Redis plugin is designed to be fast, scalable, and secure. It supports a subset of the full Redis API, including:

- [Transactions](#transactions) for things like counting votes atomically in polls
- [String operations](#strings) for persisting information
- [Number operations](#numbers) for incrementing numbers
- [Sorted sets](#sorted-set) for creating leaderboards
- [Hashes](#hash) for managing a collection of key-value pairs
- [Bitfields](#bitfield) for efficient operation on sequences of bits

Each app version installed on a subreddit is namespaced, which means Redis data is siloed from other subreddits. Keep in mind that there won‚Äôt be a single source of truth for all installations of your app, since each app installation can only access the data that it has stored in the Redis database.

## Limits and quotas

- Max commands per second: 1000
- Max request size: 5 MB
- Max storage: 500 MB

All limits are applied at a per-installation granularity.

## Examples

### Menu actions

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```js title="devvit.json"
  {
    "menuActions": [
      {
      "label": "Redis Test",
      "endpoint": "/internal/menu/redis-test",
      "forUserType": "moderator",
      "location": "subreddit"
      }
    ]
  }
  ```
  ```ts title="server/index.ts"
  // Assumes Express.js
  import { redis } from '@devvit/redis';
  router.post("/internal/menu/redis-test", async (_req, res: Response<UiResponse>) => {
    const key = 'hello';
    await redis.set(key, 'world');
    const value = await redis.get(key);
    console.log(`${key}: ${value}`);
  });
  ``` 
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts
  Devvit.addMenuItem({
    location: 'subreddit',
    label: 'Test Redis',
    onPress: async (event, { redis }) => {
      const key = 'hello';
      await redis.set(key, 'world');
      const value = await redis.get(key);
      console.log(`${key}: ${value}`);
    },
  });
  ```
  </TabItem>
</Tabs>


### Games

You can take a look at this [Game Template](https://github.com/reddit/devvit-template-phaser/) to see a basic implementation of Redis in a game built with Phaser.JS

## Supported Redis commands

:::note
Not all Redis features are supported. If you would like to request a specific Redis feature, please reach out to our team [via modmail](https://www.reddit.com/message/compose/?to=%2Fr%2FDevvit) or Discord.
:::

For all examples below, we assume that you already have obtained a Redis Client. Here's how to obtain a Redis Client for Devvit Web, Devvit Blocks and Mod Tools:

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```json title="devvit.json"
  {
    "permissions": {
      "redis": true
    }
  }
  ```
  ```ts title="server/index.ts"
  import { redis } from '@devvit/redis';
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts title="devvit.tsx"
  import { Devvit } from '@devvit/public-api';
  
  Devvit.configure({
    redis: true,
  });

  //Then, in any function that has a reference to Devvit.Context:
  const redis = context.redis;
  ```
  </TabItem>
</Tabs>


### Simple read/write

| **Command**                                | **Action**                                                            |
| ------------------------------------------ | --------------------------------------------------------------------- |
| [get](https://redis.io/commands/get)       | Gets the value of key.                                                |
| [set](https://redis.io/commands/set)       | Sets key to hold a string value.                                      |
| [exists](https://redis.io/commands/exists) | Returns number of given keys that exist.                              |
| [del](https://redis.io/commands/del)       | Removes the specified keys.                                           |
| [type](https://redis.io/commands/type)     | Returns the string representation of the type of value stored at key. |
| [rename](https://redis.io/commands/rename) | Renames a key.                                                        |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function simpleReadWriteExample() {
  // Set a key
  await redis.set('color', 'red');

  // Check if a key exists
  console.log('Key exists: ' + (await redis.exists('color')));

  // Get a key
  console.log('Color: ' + (await redis.get('color')));

  // Get the type of a key
  console.log('Type: ' + (await redis.type('color')));

  // Delete a key
  await redis.del('color');
}
```

```bash
Color: red
Type: string
```

</details>

### Batch read/write

| **Command**                            | **Action**                                      |
| -------------------------------------- | ----------------------------------------------- |
| [mGet](https://redis.io/commands/mget) | Returns the values of all specified keys.       |
| [mSet](https://redis.io/commands/mset) | Sets the given keys to their respective values. |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function batchReadWriteExample() {
  // Set multiple keys at once
  await redis.mSet({
    name: 'Devvit',
    occupation: 'Developer',
    yearsOfExperience: '9000',
  });

  // Get multiple keys
  console.log('Result: ' + (await redis.mGet(['name', 'occupation'])));
}
```

```bash
Result: Devvit,Developer
```

</details>

### Strings

| **Command**                                    | **Action**                                                                                                             |
| ---------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- |
| [getRange](https://redis.io/commands/getrange) | Returns the substring of the string value stored at key, determined by the offsets start and end (both are inclusive). |
| [setRange](https://redis.io/commands/setrange) | Overwrites part of the string stored at key, starting at the specified offset, for the entire length of value.         |
| [strLen](https://redis.io/commands/strlen)     | Returns the length of the string value stored at key.                                                                  |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function stringsExample() {
  // First, set 'word' to 'tacocat'
  await redis.set('word', 'tacocat');

  // Use getRange() to get the letters in 'word' between index 0 to 3, inclusive
  console.log('Range from index 0 to 3: ' + (await redis.getRange('word', 0, 3)));

  // Use setRange() to insert 'blue' at index 0
  await redis.setRange('word', 0, 'blue');

  console.log('Word after using setRange(): ' + (await redis.get('word')));

  // Use strLen() to verify the word length
  console.log('Word length: ' + (await redis.strLen('word')));
}
```

```bash
Range from index 0 to 3: taco
Word after using setRange(): bluecat
Word length: 7
```

</details>

### Hash

Redis hashes can store up to ~ 4.2 billion key-value pairs. We recommend using hash for managing collections of key-value pairs whenever possible and iterating over it using a combination of `hscan`, `hkeys` and `hgetall`.

| **Command**                                   | **Action**                                                                        |
| --------------------------------------------- | --------------------------------------------------------------------------------- |
| [hGet](https://redis.io/commands/hget)        | Returns the value associated with field in the hash stored at key.                |
| [hMGet](https://redis.io/commands/hmget)      | Returns the value of all specified field in the hash stored at multiple keys.     |
| [hSet](https://redis.io/commands/hset/)       | Sets the specified fields to their respective values in the hash stored at key.   |
| [hSetNX](https://redis.io/commands/hsetnx/)   | Sets field in the hash stored at key to value, only if field does not yet exist.∆í |
| [hDel](https://redis.io/commands/hdel/)       | Removes the specified fields from the hash stored at key.                         |
| [hGetAll](https://redis.io/commands/hgetall/) | Returns a map of fields and their values stored in the hash.                      |
| [hKeys](https://redis.io/commands/hkeys/)     | Returns all field names in the hash stored at key.                                |
| [hScan](https://redis.io/commands/hscan/)     | Iterates fields of Hash types and their associated values.                        |
| [hIncrBy](https://redis.io/commands/hincrby/) | Increments the score of member in the sorted set stored at key by value.          |
| [hLen](https://redis.io/commands/hlen/)       | Returns the number of fields contained in the hash stored at key.                 |

<details>
  <summary>
    Code Examples
  </summary>

**Example 1**

```tsx
// Example using hGet(), hSet(), and hDel()
async function hashExample1() {
  // Set 'inventory' with multiple fields and values
  await redis.hSet('inventory', {
    sword: '1',
    potion: '4',
    shield: '2',
    stones: '8',
  });

  // Get the value of 'shield' from 'inventory'
  console.log('Shield count: ' + await redis.hGet('inventory', 'shield'));

  // Get the values of both of 'shield' and 'potion' from 'inventory'
  console.log('Shield and potion count: ' + await redis.hMGet('inventory', ['shield', 'potion']));

  // Delete some fields from 'inventory'
  console.log(
    'Number of fields deleted: ' +
      await redis.hDel('inventory', ['sword', 'shield', 'stones']);
  );
}
```

```bash
Shield count: 2
Shield and potion count: 2,4
Number of fields deleted: 3
```

---

**Example 2**

```tsx
// Example using hGetAll()
async function hashExample2() {
  // Set 'groceryList' to fields containing products with quantities
  await redis.hSet('groceryList', {
    eggs: '12',
    apples: '3',
    milk: '1',
  });

  // Get the groceryList record
  const record = await redis.hGetAll('groceryList');

  if (record != undefined) {
    console.log('Eggs: ' + record.eggs + ', Apples: ' + record.apples + ', Milk: ' + record.milk);
  }
}
```

```bash
Eggs: 12, Apples: 3, Milk: 1
```

---

**Example 3**

```tsx
// Example using hKeys()
async function hashExample3() {
  await redis.hSet('prices', {
    chair: '48',
    desk: '95',
    whiteboard: '23',
  });

  console.log('Keys: ' + (await redis.hKeys('prices')));
}
```

```bash
Keys: chair,desk,whiteboard
```

---

**Example 4**

```tsx
// Example using hScan()
async function hashExample4() {
  await redis.hSet('userInfo', {
    name: 'Bob',
    startDate: '01-05-20',
    totalAwards: '12',
  });

  // Scan and interate over all the fields within 'userInfo'
  const hScanResponse = await redis.hScan('userInfo', 0);

  hScanResponse.fieldValues.forEach((x) => {
    console.log("Field: '" + x.field + "', Value: '" + x.value + "'");
  });
}
```

```bash
Field: 'name', Value: 'Bob'
Field: 'totalAwards', Value: '12'
Field: 'startDate', Value: '01-05-20'
```

---

**Example 5**

```tsx
// Example using hIncrBy()
async function hashExample5() {
  // Set user123's karma to 100
  await redis.hSet('user123', { karma: '100' });

  // Increase user123's karma by 5
  console.log('Updated karma: ' + (await redis.hIncrBy('user123', 'karma', 5)));
}
```

```bash
Updated karma: 105
```

---

**Example 6**

```tsx
// Example using hLen()
async function hashExample6() {
  await redis.hSet('supplies', {
    paperclips: '25',
    pencils: '10',
    erasers: '5',
    pens: '7',
  });

  console.log('Number of fields: ' + (await redis.hLen('supplies')));
}
```

```bash
Number of fields: 4
```

</details>

### Numbers

| **Command**                                | **Action**                                        |
| ------------------------------------------ | ------------------------------------------------- |
| [incrBy](https://redis.io/commands/incrby) | Increments the number stored at key by increment. |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function numbersExample() {
  await redis.set('totalPoints', '53');

  console.log('Updated points: ' + (await redis.incrBy('totalPoints', 100)));
}
```

```bash
Updated points: 153
```

</details>

### Key expiration

| **Command**                                         | **Action**                                                        |
| --------------------------------------------------- | ----------------------------------------------------------------- |
| [expire](https://redis.io/commands/expire/)         | Sets a timeout on key.                                            |
| [expireTime](https://redis.io/commands/expiretime/) | Returns the remaining seconds at which the given key will expire. |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function keyExpirationExample() {
  // Set a key 'product' with value 'milk'
  await redis.set('product', 'milk');

  // Get the current expireTime for the product
  console.log('Expire time: ' + (await redis.expireTime('product')));

  // Set the product to expire in 60 seconds
  await redis.expire('product', 60);

  // Get the updated expireTime for the product
  console.log('Updated expire time: ' + (await redis.expireTime('product')));
}
```

```bash
Expire time: 0
Updated expire time: 60
```

</details>

### [Transactions](https://redis.io/topics/transactions)

Redis transactions allow a group of commands to be executed in a single isolated step. For example, to implement voting action in a polls app, these three actions need to happen together:

- Store the selected option for the user.
- Increment the count for selected option.
- Add the user to voted user list.

The `watch` command provides an entrypoint for transactions. It returns a [TxClientLike](https://developers.reddit.com/docs/api/public-api/#-txclientlike) which can be used to call `multi`, `exec`, `discard`, `unwatch`, and all other Redis commands to be executed within a transaction.

You can sequence all of the above steps in a single transaction using `multi` and `exec` to ensure that either all of the steps happen together or none at all.

If an error occurs inside a transaction before `exec` is called, Redis discards the transaction automatically. See the Redis docs: [Errors inside a transaction](https://redis.io/docs/latest/develop/interact/transactions/#errors-inside-a-transaction) for more info.

| **Command**                                   | **Action**                                                                                                                                                                                                                                      |
| --------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [multi](https://redis.io/commands/multi/)     | Marks the start of a transaction block.                                                                                                                                                                                                         |
| [exec](https://redis.io/commands/exec/)       | Executes all previously queued commands in a transaction and restores the connection state to normal.                                                                                                                                           |
| [discard](https://redis.io/commands/discard/) | Flushes all previously queued commands in a transaction and restores the connection state to normal.                                                                                                                                            |
| [watch](https://redis.io/commands/watch/)     | Marks the given keys to be watched for conditional execution of a transaction. `watch` returns a [TxClientLike](https://developers.reddit.com/docs/api/public-api/#-txclientlike) which should be used to call Redis commands in a transaction. |
| [unwatch](https://redis.io/commands/unwatch/) | Flushes all the previously watched keys for a transaction.                                                                                                                                                                                      |

<details>
  <summary>
    Code Examples
  </summary>

**Example 1**

```tsx
// Example using exec()
async function transactionsExample1() {
  await redis.mSet({ quantity: '5', karma: '32' });

  const txn = await redis.watch('quantity');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('karma', 10);
  await txn.set('name', 'Devvit');
  await txn.exec(); // Execute the commands in the transaction

  console.log(
    'Keys after completing transaction: ' +
      (await redis.mGet(['quantity', 'karma', 'name']))
  );
}
```

```bash
Keys after completing transaction: 5,42,Devvit
```

---

**Example 2**

```tsx
// Example using discard()
async function transactionsExample2() {
  await redis.set('price', '25');

  const txn = await redis.watch('price');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('price', 5);
  await txn.discard(); // Discard the commands in the transaction

  console.log('Price value: ' + (await redis.get('price'))); // 'price' should still be '25'
}
```

```bash
Price value: 25
```

---

**Example 3**

```tsx
// Example using unwatch()
async function transactionsExample3() {
  await redis.set('gold', '50');

  const txn = await redis.watch('gold');

  await txn.multi(); // Begin a transaction
  await txn.incrBy('gold', 30);
  await txn.unwatch(); // Unwatch "gold"

  // Now that "gold" has been unwatched, we can increment its value
  // outside the transaction without canceling the transaction
  await redis.incrBy('gold', -20);

  await txn.exec(); // Execute the commands in the transaction

  console.log('Gold value: ' + (await redis.get('gold'))); // The value of 'gold' should be 50 + 30 - 20 = 60
}
```

```bash
Gold value: 60
```

</details>

### Sorted set

| **Command**                                                     | **Action**                                                                                                                                                                                                                                                      |
| --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| [zAdd](https://redis.io/commands/zadd/)                         | Adds all the specified members with the specified scores to the sorted set stored at key.                                                                                                                                                                       |
| [zCard](https://redis.io/commands/zcard)                        | Returns the sorted set cardinality (number of elements) of the sorted set stored at key.                                                                                                                                                                        |
| [zRange](https://redis.io/commands/zrange/)                     | Returns the specified range of elements in the sorted set stored at key. <br /><br /> When using `by: 'lex'`, the start and stop inputs will be prepended with `[` by default, unless they already begin with `[`, `(` or are one of the special values `+` or `-`. |
| [zRem](https://redis.io/commands/zrem/)                         | Removes the specified members from the sorted set stored at key.                                                                                                                                                                                                |
| [zScore](https://redis.io/commands/zscore/)                     | Returns the score of member in the sorted set at key.                                                                                                                                                                                                           |
| [zRank](https://redis.io/commands/zrank/)                       | Returns the rank of member in the sorted set stored at key.                                                                                                                                                                                                     |
| [zIncrBy](https://redis.io/commands/zincrby/)                   | Increments the score of member in the sorted set stored at key by value.                                                                                                                                                                                        |
| [zScan](https://redis.io/commands/zscan/)                       | Iterates elements of sorted set types and their associated scores. Note that there is no guaranteed ordering of elements in the result.                                                                                                                         |
| [zRemRangeByLex](https://redis.io/commands/zremrangebylex/)     | When all elements in a sorted set are inserted with the same score, this command removes the elements at key between the lexicographical range specified by min and max.                                                                                        |
| [zRemRangeByRank](https://redis.io/commands/zremrangebyrank/)   | Removes all elements in the sorted set stored at key with rank between start and stop.                                                                                                                                                                          |
| [zRemRangeByScore](https://redis.io/commands/zremrangebyscore/) | Removes all elements in the sorted set stored at key with a score between min and max (inclusive).                                                                                                                                                              |

<details>
  <summary>
    Code Examples
  </summary>

**Example 1**

```tsx
// Example using zRange() with by 'score'
async function sortedSetExample1() {
  await redis.zAdd(
    'leaderboard',
    { member: 'louis', score: 37 },
    { member: 'fernando', score: 10 },
    { member: 'caesar', score: 20 },
    { member: 'alexander', score: 25 }
  );

  // Cardinality should be '4' as there are 4 elements in the leaderboard set
  console.log('Cardinality: ' + (await redis.zCard('leaderboard')));

  // View elements with scores between 0 and 30 inclusive, sorted by score
  let scores = await redis.zRange('leaderboard', 0, 30, { by: 'score' });
  console.log('Scores: ' + JSON.stringify(scores));

  // Remove 'fernando' from the leaderboard
  await redis.zRem('leaderboard', ['fernando']);

  // View the elements sorted by score again. This time 'fernando' should not appear in the output
  scores = await redis.zRange('leaderboard', 0, 30, { by: 'score' });
  console.log('Updated scores: ' + JSON.stringify(scores));

  // View caesar's score
  console.log("Caesar's score: " + (await redis.zScore('leaderboard', 'caesar')));
}
```

```bash
Cardinality: 4
Scores: [{"score":10,"member":"fernando"},{"score":20,"member":"caesar"},{"score":25,"member":"alexander"}]
Updated scores: [{"score":20,"member":"caesar"},{"score":25,"member":"alexander"}]
Caesar's score: 20
```

---

**Example 2**

```tsx
// Example using zRange() with by 'lex'
async function sortedSetExample2() {
  await redis.zAdd(
    'checkpoints',
    { member: 'delta', score: 0 },
    { member: 'omega', score: 0 },
    { member: 'alpha', score: 0 },
    { member: 'charlie', score: 0 }
  );

  // View elements between the words 'alpha' and 'fox' inclusive, sorted lexicographically
  // Note that 'by: "lex"' only works if all elements have the same score
  const members = await redis.zRange('checkpoints', 'alpha', 'fox', { by: 'lex' });
  console.log('Members: ' + JSON.stringify(members));
}
```

```bash
Members: [{"score":0,"member":"alpha"},{"score":0,"member":"charlie"},{"score":0,"member":"delta"}]
```

---

**Example 3**

```tsx
// Example using zRange() with by 'rank'
async function sortedSetExample3() {
  await redis.zAdd(
    'grades',
    { member: 'sam', score: 80 },
    { member: 'norma', score: 95 },
    { member: 'alex', score: 77 },
    { member: 'don', score: 84 },
    { member: 'zeek', score: 92 }
  );

  // View elements with a rank between 2 and 4 inclusive. Note that ranks start at index 0.
  const members = await redis.zRange('grades', 2, 4, { by: 'rank' });
  console.log('Members: ' + JSON.stringify(members));
}
```

```bash
Members: [{"score":84,"member":"don"},{"score":92,"member":"zeek"},{"score":95,"member":"norma"}]
```

---

**Example 4**

```tsx
// Example using zRank() and zIncrBy()
async function sortedSetExample4() {
  await redis.zAdd(
    'animals',
    { member: 'zebra', score: 92 },
    { member: 'cat', score: 100 },
    { member: 'dog', score: 95 },
    { member: 'elephant', score: 97 }
  );

  // View the rank of 'dog' in the animals set
  // Rank should be '1' since 'dog' has the second lowest score. Note that ranks start at index 0.
  console.log("Dog's rank: " + (await redis.zRank('animals', 'dog')));

  // View the rank of 'zebra'
  console.log("Zebra's rank: " + (await redis.zRank('animals', 'zebra')));

  // Increase the score of 'dog' by 10
  await redis.zIncrBy('animals', 'dog', 10);

  // View the rank of 'dog' again. This time it should be '3' because dog has the highest score.
  console.log(
    "Dog's rank after incrementing score: " + (await redis.zRank('animals', 'dog'))
  );
}
```

```bash
Dog's rank: 1
Zebra's rank: 0
Dog's rank after incrementing score: 3
```

---

**Example 5**

```tsx
// Example using zRemRangeByLex()
async function sortedSetExample5() {
  await redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 0 },
    { member: 'mango', score: 0 },
    { member: 'banana', score: 0 },
    { member: 'orange', score: 0 },
    { member: 'apple', score: 0 }
  );

  // Remove fruits alphabetically ordered between 'kiwi' inclusive and 'orange' exclusive
  // Note: The symbols '[' and '(' indicate inclusive or exclusive, respectively. These must be included in the call to zRemRangeByLex().
  await redis.zRemRangeByLex('fruits', '[kiwi', '(orange');

  // Only 'apple', 'banana', and 'orange' should remain in the set
  const zScanResponse = await redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":0,"member":"apple"},{"score":0,"member":"banana"},{"score":0,"member":"orange"}]}
```

---

**Example 6**

```tsx
// Example using zRemRangeByRank()
async function sortedSetExample6() {
  await redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 10 },
    { member: 'mango', score: 20 },
    { member: 'banana', score: 30 },
    { member: 'orange', score: 40 },
    { member: 'apple', score: 50 }
  );

  // Remove fruits ranked 1 through 3 inclusive
  await redis.zRemRangeByRank('fruits', 1, 3);

  // Only 'kiwi' and 'apple' should remain in the set
  const zScanResponse = await redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":10,"member":"kiwi"},{"score":50,"member":"apple"}]}
```

---

**Example 7**

```tsx
// Example using zRemRangeByScore() example
async function sortedSetExample7() {
  await redis.zAdd(
    'fruits',
    { member: 'kiwi', score: 10 },
    { member: 'mango', score: 20 },
    { member: 'banana', score: 30 },
    { member: 'orange', score: 40 },
    { member: 'apple', score: 50 }
  );

  // Remove fruits scored between 30 and 50 inclusive
  await redis.zRemRangeByScore('fruits', 30, 50);

  // Only 'kiwi' and 'mango' should remain in the set
  const zScanResponse = await redis.zScan('fruits', 0);
  console.log('zScanResponse: ' + JSON.stringify(zScanResponse));
}
```

```bash
zScanResponse: {"cursor":0,"members":[{"score":10,"member":"kiwi"},{"score":20,"member":"mango"}]}
```

</details>

### Bitfield

| **Command**                                                 | **Action**                                        |
| ----------------------------------------------------------- | ------------------------------------------------- |
| [bitfield](https://redis.io/docs/latest/commands/bitfield/) | Performs a sequence of operations on a bit string |

<details>
  <summary>
    Code Example
  </summary>

```tsx
async function bitfieldExample() {
  const setBits: number[] = await redis.bitfield('foo', 'set', 'i5', '#0', 11);
  console.log('Set result: ' + setBits); // [0]

  const getBits: number[] = await redis.bitfield('foo', 'get', 'i5', '#0');
  console.log('Get result: ' + setBits); // [11]

  const manyOperations: number[] = await redis.bitfield(
    'bar',
    'set',
    'u2',
    0,
    3,
    'get',
    'u2',
    0,
    'incrBy',
    'u2',
    0,
    1,
    'overflow',
    'sat',
    'get',
    'u2',
    0,
    'set',
    'u2',
    0,
    3,
    'incrBy',
    'u2',
    0,
    1
  );
  console.log('Results of many operations: ' + manyOperations); // [0, 3, 0, 0, 3, 3]
}
```

```bash
fooResults: [1, 0]
barResults: [0, 3, 0, 0, 3, 3]
```

</details>


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Overview

The Reddit API allows you to read and write Reddit content such as posts / comments / upvotes, in order to integrate your app's behavior with the content of the community it's installed in.

## The Reddit client

Here's how to obtain a reference to the Reddit client

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```json title="devvit.json"
  {
    "permissions": {
      "reddit": true
    }
  }
  ```
  ```ts title="server/index.ts"
  import { reddit } from '@devvit/reddit';
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts title="devvit.tsx"
  import { Devvit } from '@devvit/public-api';
  
  Devvit.configure({
    redditAPI: true,
  });

  //Then, in any function that has a reference to Devvit.Context:
  const reddit = context.reddit;
  ```
  </TabItem>
</Tabs>

## Example usage

### Submitting a post
<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts
import { Devvit } from '@devvit/public-api';
import { context, reddit } from '@devvit/web/server';

export const createPost = async () => {
  const { subredditName } = context;
  if (!subredditName) {
    throw new Error('subredditName is required');
  }

  return await reddit.submitCustomPost({
    userGeneratedContent: {
      text: 'Hello there! This is a post from a Devvit app',
    },
    subredditName: subredditName,
    title: 'New Post',
    splash: { appDisplayName: 'Test App' },
  });
};
  ```
</TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">

```tsx
import { Devvit } from '@devvit/public-api';

Devvit.configure({
  redditAPI: true,
});

function createPost(context: Devvit.Context) {
  const currentSubreddit = context.reddit.getCurrentSubreddit();
  if (!currentSubreddit) {
    throw new Error('No subreddit found');
  }

  return context.reddit.submitPost({
    title: 'My custom post',
    subredditName: currentSubreddit.name,
    preview: (
      <vstack height="100%" width="100%" alignment="middle center">
        <text size="large">Loading...</text>
      </vstack>
    ),
  });
}
```
</TabItem>
</Tabs>

### Submitting a comment

<Tabs>
    <TabItem value="web" label="Devvit Web">
    ```ts
        import { context, reddit } from '@devvit/web/server';

        export const createComment = async () => {
            const { subredditName } = context;
            if (!subredditName) {
                throw new Error('subredditName is required');
            }

            reddit.submitComment({
                postId: 't3_123456', // Replace with the actual post ID
                text: 'This is a comment from a Devvit app',
                runAs: 'USER' // Optional: specify the user to run as
            });
        };
```
    </TabItem>
    <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
    ```tsx
        import { Devvit } from '@devvit/public-api';

        Devvit.configure({
            redditAPI: true,
        });

        function createComment(context: Devvit.Context) {
            const { reddit } = context;

            reddit.submitComment({
                postId: 't3_123456', // Replace with the actual post ID
                text: 'This is a comment from a Devvit app',
                runAs: RunAs.USER, // Optional: specify the user to run as
            });
        };
```
    </TabItem>
</Tabs>


---


import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Post Data

You can attach small amounts of data (2KB) to a post when creating it and update this data using the `postData` capability. This enables dynamic, stateful experiences available on posts without a server call. Post data is scoped to the post, not users.

Post data is useful for storing game state, scores, or any other information that needs to persist with the post and be shared across all users.

Post data is set when you submitPost and apps can access from the context object or do a server side call to update the post data on a Post object. For larger data, use [./redis.mdx].

:::note
Post data is sent to the client. Never store secrets or sensitive information.
:::

## Creating posts with data
When creating a post, include the `postData` parameter with your custom data object.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts title="server/index.ts"
  import { reddit } from '@devvit/web/server';

  const post = await reddit.submitCustomPost({
    subredditName: context.subredditName!,
    title: 'Post with custom data',
    splash: {
      appDisplayName: 'Test App',
    },
    postData: {
      challengeNumber: 42,
      totalGuesses: 0,
      gameState: 'active',
      pixels: [
        [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0],
        [0, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0],
        [0, 0, 0, 2, 2, 1, 1, 1, 0, 0, 0],
        [0, 0, 2, 2, 1, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 2, 2, 2, 2, 2, 2, 2, 1, 1],
        [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 2, 2, 1, 1, 1, 1, 1, 0, 0],
        [0, 0, 0, 2, 2, 1, 1, 1, 0, 0, 0],
        [0, 0, 0, 0, 2, 2, 1, 0, 0, 0, 0],
        [0, 0, 0, 0, 0, 2, 0, 0, 0, 0, 0]
     ] // Drawing canvas data
    },
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  ```ts title="main.tsx"
  import { Devvit } from '@devvit/public-api';

  Devvit.addMenuItem({
    label: 'Create custom post',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const post = await context.reddit.submitPost({
        subredditName: context.subredditName!,
        title: 'My custom post',
        preview: (
          <vstack height="100%" width="100%" alignment="middle center">
            <text size="large">Loading ...</text>
          </vstack>
        ),
        postData: {
          "riddle": "A very clever riddle",
          "scores": {
            "team1": "Team 1",
            "team2": "Team 2",
          },
        }
      });
      context.ui.showToast(`Created post with ID ${post.id}`);
      context.ui.navigateTo(post);
    },
  });
  ```
  </TabItem>
</Tabs>

## Updating post data
To update post data after creation, fetch the post and use the `setPostData()` method.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts title="server/index.ts"
  import { reddit } from '@devvit/web/server';

  const post = await reddit.getPostById('t3_your_post_id');
  await post.setPostData({ 'moreStuff': 'hello' });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  ```ts title="main.tsx"
  import { Devvit, useForm } from '@devvit/public-api';

  Devvit.addCustomPostType({
    name: 'InteractivePost',
    render: (context) => {
      const updateForm = useForm(
        {
          fields: [
            { type: 'string', name: 'favColor', label: 'Favorite color' },
          ],
        },
        async (values) => {
          const post = await context.reddit.getPostById(context.postId!);
          const currentUsername = await context.reddit.getCurrentUsername();
          
          await post.setPostData({
            'favColor': values.favColor || 'unknown',
            'user': currentUsername!
          });
          
          context.ui.showToast('Updated post data!');
        }
      );

      return (
        <button onPress={() => context.ui.showForm(updateForm)}>
          Update post data
        </button>
      );
    },
  });
  ```
  </TabItem>
</Tabs>

:::warning
`setPostData()` replaces the entire post data object. To update specific fields while preserving others, merge the existing data with your updates.
:::

## Accessing post data
Post data is available through `context.postData` in both client and server contexts.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```tsx title="client/index.tsx"
  import { context } from '@devvit/web/client';

  export const App = () => {
    return (
      <div>
        <text className='mt-1 font-bold'>Post Data:</text>
        <text>{JSON.stringify(context.postData, null, 2) ?? 'undefined'}</text>
      </div>
    );
  }
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks">
  ```tsx title="main.tsx"
  import { Devvit } from '@devvit/public-api';

  Devvit.addCustomPostType({
    name: 'MyCustomPost',
    render: (context) => {
      return (
        <vstack alignment='middle center'>
          <text size='medium'>context.postData:</text>
          <text size='medium'>{JSON.stringify(context.postData, null, 2)}</text>
        </vstack>
      );
    },
  });
  ```
  </TabItem>
</Tabs>

## Limitations
Post data supports:
- JSON-serializable objects only
- Maximum size of 2KB
- Data persists with the post lifecycle (deleted when post is deleted)
- Updates to post data don't trigger automatic re-renders. Implement polling or refresh mechanisms as needed


---

# Overview

Devvit offers a wide variety of features that help you integrate your app with Reddit's APIs, scale your app free of charge using Reddit's backend, and more. The features in this section are executed on the server side. They can be imported in both [Devvit Web](../devvit-web/devvit_web_overview.mdx) and [Devvit Blocks](../blocks/overview.md) applications, as well as Mod Tools.

Below is a brief explanation of all features in this section:

## [HTTP fetch](./http-fetch.mdx)

Allows you to make HTTP requests to external servers, subject to a review of the specific domains you are requesting from.

## [Media uploads](./media-uploads.mdx)

Allows you to build apps where the end user can upload custom images to Reddit's CDN. Uploaded media is subject to the same safety checks as every other media content uploaded to Reddit, ensuring community safety.

## [Reddit API](./reddit-api.mdx)

Allows you to query information from Reddit such as comments, posts and upvotes. Limited to installation scope of the application.

## [Scalable storage (Redis)](./redis.mdx)

Allows you to store app data in a scalable database, free of charge. Limited to the installation scope of the application.

## [Scheduler](./scheduler.md)

Allows you to run automated server-side tasks on a schedule, for example, checking for updates every hour.

## [Secrets storage](./settings-and-secrets.mdx)

Allows you to build an app where the moderator can store secret keys in a safe and scalable way. For example, if your app needs the installing moderator to provide their own keys to an external API.

## [Triggers](./triggers)

Allows you to run automated server-side tasks when certain events happen on Reddit, for example: when a new post is created, or when a new comment is created.

## [User actions](./userActions.md)

Allows you to execute some actions, like posting or commenting, on behalf of the user. This means that these new posts or comments will not show up as created by the app, but by the user that is currently using the app. Access to this feature is subject to review by Admins.

## [Text fallback](./text_fallback.mdx)

Allows you to specify how your interactive post is displayed on platforms that don't support Devvit, for example old.reddit.com

## [Cache helper](./cache-helper.mdx)

Allows you to cache fetch requests on the server side, reducing the number of requests made to external APIs and improving performance.


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Media Uploads

:::warning
Apps can only display images hosted on Reddit
:::

You can upload images to Reddit at runtime using the `media` capability. This is different than static images, which are part of your [assets](../blocks/app_image_assets.md).

Runtime images are useful for embedding images in RTJSON (Posts and Comments) as well as displaying them within an interactive post app.

## Enabling media uploads
Enable the `media` permission in your `devvit.json` file.
```json title="devvit.json"
{
  "permissions": {
    "media": true
  }
}
```

## Using media uploads
On the server, you can pass the URL of any remotely hosted image (even if its not hosted on Reddit) to the `media.upload` function. The media function will return a Reddit URL.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts title="server/index.ts"
  import { media } from '@devvit/media';
  function submitImage() {
    const response = await media.upload({
      url: 'https://media2.giphy.com/media/xTiN0CNHgoRf1Ha7CM/giphy.gif',
      type: 'gif',
    });
  }
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts
  import { Devvit } from '@devvit/public-api';

  const response = await media.upload({
    url: 'https://media2.giphy.com/media/xTiN0CNHgoRf1Ha7CM/giphy.gif',
    type: 'gif',
  });
  ```
  </TabItem>
</Tabs>


## Limitations
Supported file types are:
- GIF
- PNG
- JPEG

Maximum size is 20 MB.


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# HTTP Fetch

Make requests to allow-listed external domains.

Your Devvit app can make network requests to access allow-listed external domains using HTTP Fetch. This enables your app to leverage webhooks, personal servers, and other third-party integrations asynchronously across the network.

## Enabling HTTP fetch calls

<Tabs>
  <TabItem value="devvit.json" label="Devvit Web">
  ```json title="devvit.json"
  {
    ...
    "permissions": {
      "http": {
        "enable": true,
        "domains": ["my-site.com", "another-domain.net"]
      }
    }
  }
  ```
  </TabItem>
  <TabItem value="devvit.tsx" label="Devvit Blocks / Mod Tools">
  ```ts
  import { Devvit } from '@devvit/public-api';

  Devvit.configure({
    http: {
      domains: ['my-site.com', 'another-domain.net'],
    },
  });

```
  </TabItem>
</Tabs>

### Requesting a domain to be allow-listed

Apps may request a domain to be added to the allow-list by specifying `domains` in the `http` configuration.
This configuration is optional, and apps can still configure `http: true` as before.

Requested domains will be submitted for review when you playtest or upload your app. Admins may approve or deny domain requests.

Domain entries must be exact hostnames only, such as nytimes.com or wikipedia.org. These fetch requests are not allowed:

- Be specific. No using `*.example.com` when you need `api.example.com`
- No wildcards: `*.example.com`
- No protocols: `https://api.example.com`
- No paths: `api.example.com/webhooks`

Domains that are approved for your app will be displayed in the Developer Settings section for your app at `https://developers.reddit.com/apps/{your-app-slug}/developer-settings`.
These domains are allow-listed for **your app only** and not globally.

Apps must request each individual domain that it intends to fetch, even if the domain is already globally allowed. See the [global fetch allowlist](#global-fetch-allowlist) to view the list of globally allowed domains.

## Limitations

- Access is only allowed to https URIs.
- Supported HTTP methods: `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS` and `PATCH`.
- HTTP timeout limit is 30 seconds.

## Example usage

<Tabs>
  <TabItem value="devvit-web" label="Devvit Web">
  
  Devvit Web applications have two different contexts for using fetch:
  
  ### Server-side fetch
  
  Server-side fetch allows your app to make HTTP requests to allowlisted external domains from your server-side code (e.g., API routes, server actions):
  
  ```ts
  // In your server-side code
  const response = await fetch('https://example.com/api/data', {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
    },
  });
  
  const data = await response.json();
  console.log('External API response:', data);
  ```
  
  ### Client-side fetch
  
  Client-side fetch has different restrictions and can only make requests to your own webview domain:
  
  **Client-side restrictions:**
  - **Domain limitation**: Can only make requests to your own webview domain
  - **Endpoint requirement**: All requests must target endpoints that end with `/api`
  - **Authentication**: Handled automatically - no need to manage auth tokens
  - **No external domains**: Cannot make requests to external domains from client-side code
  
  ```ts
  // In your client-side React components or browser code
  const handleFetchData = async () => {
    // ‚úÖ Correct: Fetching your own webview's API endpoint
    const response = await fetch('/api/user-data', {
      method: 'GET',
      headers: {
        'Content-Type': 'application/json',
      },
    });
    
    const data = await response.json();
    console.log('API response:', data);
  };
  
  // ‚ùå Incorrect: Cannot fetch external domains from client-side
  // const response = await fetch('https://external-api.com/data');
  
  // ‚ùå Incorrect: Endpoint must end with /api
  // const response = await fetch('/user-data');
  ```
  
  </TabItem>
  <TabItem value="devvit-blocks" label="Devvit Blocks / Mod Tools">
  
  For Devvit Blocks and Mod Tools, fetch is available within menu actions, triggers, and other server-side contexts:
  
  ```ts
  import { Devvit } from '@devvit/public-api';
  
  Devvit.configure({
    http: {
      domains: ['example.com'],
    },
  });
  
  Devvit.addMenuItem({
    location: 'comment',
    label: 'Sample HTTP request',
    onPress: async (_event, context) => {
      console.log(`Comment ID: ${context.commentId}`);
      const response = await fetch('https://example.com', {
        method: 'post',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ content: context.commentId }),
      });
      context.ui.showToast(
        `Invoked HTTP request on comment: ${context.commentId}. Completed with status: ${response.status}`
      );
    },
  });
  
  export default Devvit;
  ```
  
  </TabItem>
</Tabs>

## Troubleshooting

If you see the following error, it means HTTP Fetch requests are hitting the internal timeout limits. To resolve this:

- Use a queue or kick off an async request in your back end. You can use [Scheduler](./scheduler.md) to monitor the result.
- Optimize the overall HTTP request latency if you have a self-hosted server.

```ts
HTTP request to domain: <domain> timed out with error: context deadline exceeded.
```

### Terms and conditions

Any app that uses `fetch` must upload Terms and Conditions and a Privacy Policy. Links to each of these documents must be saved in the app details form.

![App configuration form](../../assets/capabilities/http-fetch/http-fetch-legal-links.png)

## Global fetch allowlist {#global-fetch-allowlist}

The following domains are globally allowed and can be fetched by any app:

- example.com
- site.api.espn.com
- cdn.espn.com
- discord.com
- api.polygon.io
- polygon.io
- slack.com
- lichess.org
- api.telegram.org
- commentanalyzer.googleapis.com
- language.googleapis.com
- statsapi.mlb.com
- api.openai.com
- api.scryfall.com
- api.nasa.gov
- api.sportradar.us
- api.sportradar.com
- random.org
- generativelanguage.googleapis.com
- youtube.googleapis.com
- api.weather.gov
- wikipedia.org
- finance.yahoo.com
- api.twitter.com
- api.petfinder.com
- fonts.googleapis.com
- nytimes.com
- npr.org
- propublica.org
- pbs.org
- i.giphy.com
- chessboardjs.com



---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Cache helper

Cache helper lets you build a more performant app by reducing the number of server side calls for the same data. You can create a short-term cache that stores JSON objects in your Devvit app for a limited amount of time. This is valuable when you have many clients trying to get the same data, for example a stock ticker value or a sports score.

Under the covers, it's Redis plus a local in-memory write-through cache. This provides a pattern for fetching data without involving a scheduler and allows small time-to-live (TTL, ~1 second). Cache helper lets the app make one request for the data, save the response, and provide this response to all users requesting the same data.

:::warning
**Do not cache sensitive information**. Cache helper randomly selects one user to make the real request and saves the response to the cache for others to use. You should only use cache helper for non-personalized fetches, since the same response is available to all users.
:::


## Usage

<Tabs>
  <TabItem value="web" label="Devvit Web">
    You can import cache helper from `@devvit/web/server` in your server source files. The cache helper is not available client-side, so you will see an error if you try to import it in client source files.

    ```tsx
    import { cache } from '@devvit/web/server';
    ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
    You need to enable [Redis](../server/redis.mdx) in order to use Cache helper.

    ```tsx
    Devvit.configure({
      redis: true,
      // other capabilities
    });
    ```
  </TabItem>
</Tabs>

## Parameters

The cache takes a key and a TTL regardless of whether you are using Devvit Web or Devvit Blocks. The only difference is that **the TTL is in seconds for Devvit Web** and **milliseconds for Devvit Blocks / Mod Tools**.

<Tabs>
  <TabItem value="web" label="Devvit Web">

| **Parameters** | **Description**                                                                                                                                                                                                                                                                                                               |
| -------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `key`          | This is a string that identifies a cached response. Instead of making a real request, the app gets the cached response with the key you provide. Make sure to use different keys for different data. For example, if you‚Äôre saving post-specific data, add the postId to the cache key, like this: `post_data_${postId})`.    |
| `ttl`          | Time to live is the number of **seconds** the cached response is expected to be relevant. Once the cached response expires, it will be voided and a real request is made to populate the cache again. You can treat it as a threshold, where ttl of 30 would mean that a request is done no more than once per 30 seconds.    |

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">

| **Parameters** | **Description**                                                                                                                                                                                                                                                                                                                    |
| -------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `key`          | This is a string that identifies a cached response. Instead of making a real request, the app gets the cached response with the key you provide. Make sure to use different keys for different data. For example, if you‚Äôre saving post-specific data, add the postId to the cache key, like this: `post_data_${postId})`.         |
| `ttl`          | Time to live is the number of **milliseconds** the cached response is expected to be relevant. Once the cached response expires, it will be voided and a real request is made to populate the cache again. You can treat it as a threshold, where ttl of 30000 would mean that a request is done no more than once per 30 seconds. |

  </TabItem>
</Tabs>

## Example

Here‚Äôs a way to set up in-app caching instead of using scheduler or interval to fetch.

<Tabs>
  <TabItem value="web" label="Devvit Web">
    ```tsx
    // src/server/index.ts
    import express from "express";
    import {
      SubredditResponse,
    } from "../shared/types/api";
    import {
      cache,
      createServer,
      context,
      getServerPort,
      reddit,
    } from "@devvit/web/server";

    const app = express();

    // Middleware for JSON body parsing
    app.use(express.json());
    // Middleware for URL-encoded body parsing
    app.use(express.urlencoded({ extended: true }));
    // Middleware for plain text body parsing
    app.use(express.text());

    const router = express.Router();

    router.get<
      { postId: string },
      SubredditResponse | { status: string; message: string }
    >("/api/subreddit", async (_req, res): Promise<void> => {
      const { postId } = context;

      if (!postId) {
        console.error("API Subreddit Error: postId not found in devvit context");
        res.status(400).json({
          status: "error",
          message: "postId is required but missing from context",
        });
        return;
      }

      try {
        const subredditName = await cache(
          async () => {
            const subreddit = await reddit.getCurrentSubreddit();
            if (!subreddit) {
              throw new Error("Subreddit is required but missing from context");
            }
            return subreddit.name;
          },
          {
            key: `current_subreddit`,
            ttl: 24 * 60 * 60 // expire after one day.
          }
        );
        console.log(`Current subreddit: ${subredditName}`);

        res.json({
          type: "subreddit" as "subreddit",
          subreddit: subredditName,
        });
      } catch (error) {
        console.error(`API Subreddit Error for post ${postId}:`, error);
        let errorMessage = "Unknown error during subreddit retrieval";
        if (error instanceof Error) {
          errorMessage = `Subreddit retrieval failed: ${error.message}`;
        }
        res.status(400).json({ status: "error", message: errorMessage });
      }
    });

    app.use(router);

    const server = createServer(app);
    server.on("error", (err) => console.error(`server error; ${err.stack}`));
    server.listen(getServerPort());
    ```
  </TabItem>

  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
    ```tsx
    import { Devvit, useState } from '@devvit/public-api';

    Devvit.configure({
      redis: true,
      http: true, // to use `fetch()`
      // other capabilities
    });

    Devvit.addCustomPostType({
      name: 'Name',
      render: (context) => {
        const [data, setData] = useState({});

        async function getData() {
          const result = await context.cache(
            async () => {
              const response = await fetch('https://example.com');
              if (!response.ok) {
                throw Error(`HTTP error ${response.status}: ${response.statusText}`);
              }
              return await response.json();
            },
            {
              key: context.userId!,
              ttl: 10_000, // millis
            }
          );

          setData(result);
        }

        return (
          <blocks>
            <button
              onPress={() => {
                getData();
              }}
            >
              Load data
            </button>

            <text>{data.something}</text>
          </blocks>
        );
      },
    });

    export default Devvit;
    ```
  </TabItem>
</Tabs>


---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

# Overview
Interactive posts are the core of Reddit Dev Platform apps, enabling rich, engaging experiences that go beyond static content. There are three essential features for creating an interactive post using the Reddit API :

1. First Screen Customization
2. Post Data
3. User Actions

## Create an interactive post
Use reddit.submitCustomPost() from the Reddit library. You‚Äôll want to call this function in response to an action like a user submission, trigger, or menu item.

## Devvit Web

```tsx
// in server code

import { reddit, context } from '@devvit/web/server'

export const createPost = async () => {
  const { subredditName } = context;
  if (!subredditName) {
    throw new Error('subredditName is required');
  }

  return await reddit.submitCustomPost({
    splash: {
      appDisplayName: 'test-post-flair',
    },
    subredditName: subredditName,
    title: 'test-post-flair',
  });
};

// example action in our templates
// Then, in your devvit.json:
/*
 "menu": {
    "items": [
      {
        "label": "Create a new post",
        "description": "test-post-creator",
        "location": "subreddit",
        "forUserType": "moderator",
        "endpoint": "/internal/menu/post-create"
      }
    ]
  },
  "triggers": {
    "onAppInstall": "/internal/on-app-install"
  },
*/
  ``` 

 ###  üé® First Screen Customization

Control what users see when they first encounter your post. Choose between:
- **Splash screens**. A configurable splash screen with a clear call-to-action button, ideal for MVP-stage apps or those benefiting from immersive experiences with longer load times.
- **Inline web views (Experimental)**. Interactive experiences that load directly in posts for instant-interaction apps or dynamic first screens. This is especially beneficial for developers comfortable optimizing web performance across all devices but is subject to more guidelines and longer approval cycles.

:::tip
Start simple with a splash screen, then move towards inline web views as your app grows and you want to optimize engagement.
:::  

Learn more about [First Screen Customization](LINK).

### üíæ Post Data
 Attach up to 2KB of JSON data directly to your post for instant client-side access. Perfect for:

- Game states and scores
- Configuration settings
- Small shared data that all users need to see

For larger amounts of data, you should use [Redis](./capabilities/server/redis). Learn more about Post Data


### üë§ User Actions

Enable your app to perform actions on behalf of users (with their permission):

- Create posts or comments as the user
- Subscribe users to subreddits (coming soon)

Learn more about [User Actions](./capabilities/server/userActions)

## Example

Here's a complete example using all three features together:

```ts title="server/index.ts"
import { reddit, context } from '@devvit/web/server';
// Create an interactive post with all features

const post = await reddit.submitCustomPost({
  subredditName: context.subredditName!,
  title: 'Interactive Game Post',

  // First Screen Customization (splash screen)
  splash: {
    appDisplayName: 'Number Guessing Game',
    backgroundUri: 'game-bg.png',
    buttonLabel: 'Start Playing',
    description: 'Can you guess the secret number?',
    heading: 'Welcome to the Challenge!'
  },

  // Post Data for game state
  postData: {
    secretNumber: Math.floor(Math.random() * 100) + 1,
    totalGuesses: 0,
    gameState: 'active',
    winner: null
  }
});

// Later, update post data when someone wins
const updatedPost = await reddit.getPostById(post.id); await updatedPost.setPostData({ ...context.postData, gameState: 'completed', winner: currentUsername, totalGuesses: context.postData.totalGuesses + 1 });

// Create a comment as the user announcing their win await reddit.submitComment({ runAs: 'USER', id: post.id, text: üéâ ${currentUsername} won the game! });
```


---

import Tabs from '@theme/Tabs'; import TabItem from '@theme/TabItem';

# First Screen Customization

Control what users see when they first encounter your Devvit app post. Choose between a configuration-based splash screen or an inline web view (experimental) that launches directly into the interactive experience. Splash screens are great for:

- Getting started with your app
- Apps that require a long load time (e.g. Phaser game)
- Faster initial reviews

:::note
First screen customization is built for web view apps on Devvit Web.
:::

| **Feature**                                              | **Web** | **iOS**           | **Android**       |
| -------------------------------------------------------- | ------- | ----------------- | ----------------- |
| Splash Screens                                           | ‚úÖ      | ‚úÖ                | üü°Partial Support |
| Inline Web Views (Experimental)                          | ‚úÖ      | üü°Partial Support | üü°Partial Support |
| requestImmersiveMode for Inline Web Views (Experimental) | ‚úÖ      | üü°Partial Support | üü°Partial Support |

## Customization Options

### Splash Screens

Splash screens provide a personalized entry point for your app, displaying a customized view before users interact with your post. A well-designed splash screen improves first impressions and drives better user engagement.

The splash screen appears when users first view your post, featuring your app's branding, a description, and a call-to-action button that launches the main experience.

#### Creating Posts with Splash Screens

When creating a post with a splash screen, include the splash parameter to customize the appearance:

```ts title="server/index.ts"
import { reddit } from '@devvit/web/server';

export const createPost = async (context: DevvitContext) => {
  const post = await reddit.submitCustomPost({
    subredditName: context.subredditName!,
    title: 'My Interactive Post',
    splash: {
      appDisplayName: 'My Amazing App', // only required field
      backgroundUri: 'background.png',
      buttonLabel: 'Start Playing',
      description: 'An exciting interactive experience',
      entryUri: 'index.html',
      heading: 'Welcome to the Game!',
    },
    postData: {
      gameState: 'initial',
      score: 0,
    },
    runAs: 'USER',
  });
};
```

#### Splash Screen Properties

The splash object supports the following customization options:

| **Property**   | **Type** | **Description**                                                | **Default**                                                          |
| -------------- | -------- | -------------------------------------------------------------- | -------------------------------------------------------------------- |
| appDisplayName | string   | Your app's display name                                        | Required                                                             |
| backgroundUri  | string   | Background image URL (relative to media directory or data URI. | None, recommended for inline web views as it acts as a loading image |
| buttonLabel    | string   | Text for the launch button                                     | 'Launch App'                                                         |
| description    | string   | Secondary text describing the post experience                  | None                                                                 |
| entryUri       | string   | Web view URI relative to client directory                      | 'index.html'                                                         |
| heading        | string   | Large text naming the post under app name                      | appDisplayName                                                       |
| appIconUri     | string   | Icon URL relative to media directory or data URI               | None                                                                 |

#### Using Images

Images can be referenced in two ways:

1. Local assets: Place images in your app's assets folder and point to the assets folder in your devvit.json

For example, to use an image at assets/splash-background.png:

```tsx
// in devvit.json, make sure you have the media dir set:
// "media": {
//  "dir": "assets"
// },

// in server endpoint
await reddit.submitCustomPost({
  // ...
  splash: {
    appDisplayName: 'Example App',
    backgroundUri: 'splash-background.png',
    appIconUri: 'app-icon.png',
  },
});
```

2. Reddit URLs: Use a reddit hosted URL, which must be on an i.redd.it domain:

```tsx
// in server endpoint
await reddit.submitCustomPost({
  // ...
  splash: {
    appDisplayName: 'Example App',
    backgroundUri: 'https://i.redd.it/your-image.png',
  },
});
```

#### Example: Splash Screen

You can choose the first screen type based on context or user preferences:

```tsx
import { reddit } from '@devvit/web/server';

async function createPost(postType: 'game' | 'leaderboard', context: any) {
  const baseConfig = {
    subredditName: context.subredditName!,
    postData: {
      type: postType,
      initialized: false,
    },
  };

  return await reddit.submitCustomPost({
    ...baseConfig,
    title: 'Epic Adventure Game',
    splash: {
      appDisplayName: 'Quest Master',
      backgroundUri: 'game-splash.png',
      buttonLabel: 'Begin Quest',
      description: 'Embark on an unforgettable journey',
      heading: 'The Adventure Awaits',
    },
  });
}
```

### Inline Web Views (Experimental)

:::warning
Inline web views are currently an experimental feature and may be modified during development. We expect to have this feature fully supported across all platforms in October.
:::

Inline web views allow your app to skip the splash screen entirely and load directly into the interactive experience. This is ideal for apps where immediate interaction or apps that want more dynamic content and developers are comfortable optimizing performance and preventing conflicts with native gestures (scroll, swipe, zoom, pan).

Inline web views can launch into immersive mode on user action with the requestImmersiveMode method in ‚Äò@devvit/web/client‚Äô.

#### Example

To enable inline web views you‚Äôll have to add the inline: true property to your entrypoint. We also recommend setting a background image in your splash screen parameter which will act as your loading screen.

```tsx
// in devvit.json, make sure the following is set up:
/*
 "post": {
    "dir": "dist/client",
    "entrypoints": {
      "default": {
        "entry": "index.html",
        "inline": true
      }
    }
  },
*/

// in server files
export const createPost = async () => {
  const { subredditName } = context;
  if (!subredditName) {
    throw new Error('subredditName is required');
  }

  return await reddit.submitCustomPost({
    splash: {
      appDisplayName: 'test-init',
      backgroundUri: 'background.png', // used as loading screen
    },
    subredditName: subredditName,
    title: 'test inline web view post',
  });
};
```

#### Guidelines for Inline Web Views

Apps using inline web views are subject to additional app review to ensure performance and user experience standards. Apps must meet these requirements for approval and featuring:

- **Performance requirements** - Apps must achieve a Lighthouse score >80

- Use [Lighthouse](https://developer.chrome.com/docs/lighthouse/overview) and run your post's performance from a post view before submission.

![Lighthouse](../../assets/test-init.png)

- Optimize for mobile devices and slower connections

- **Do not interfere with native app gestures while inline** - Apps cannot interfere with native Reddit gestures
- No scroll traps or scroll hijacking
- Apps should not accept zooming or panning
- Users must be able to scroll past your post and swipe back and forth and to other relevant reddit app components naturally
- Touch gestures must work as expected
- If you need additional gestures, use within immersive mode

- **UI that works on all viewports** - Relevant content must be mobile-first and visually appealing across multiple viewport sizes (A vast majority of app engagers are on mobile devices)

- **User-initiated immersive experiences** - Apps cannot auto-launch into immersive or fullscreen modes
- Require explicit user interaction (clearly labeled button or action)
- Default view should respect standard post boundaries

:::note
You must do performance testing before submitting an app with inline web views. Run Lighthouse in Chrome DevTools to ensure your score exceeds 80. Focus on optimizing initial load time, reducing JavaScript bundle size, and minimizing layout shifts.
:::

#### Best Practices

- **Make the whole screen clickable for immersive mode** - Don't rely on small buttons alone; users expect to tap anywhere to proceed
- **Add dynamic content** - Include contextual information like post author, snoovatar, date, # of plays, current participants, or live stats to make each splash screen feel fresh
- **Use subtle animations** - Add pulse effects, gentle floating, or shimmer animations to interactive elements to signal they're clickable
- **Keep it fast** - Performance matters! Aim for splash screens that load in under 1 second. Optimize images.

#### Enabling Immersive Mode from an Inline Web View

:::Note
This is currently only available on Web and will be available on mobile platforms in October.
:::

Apps in immersive mode are able to take full control of native gestures (swipe, pan, zoom) and have better long term engagement for certain types of game experiences. When you are in the inline web view experience you can launch into immersive mode from a direct user interaction (click, touch, etc).. Immersive mode launches your web view app into a full screen context on mobile and a larger modal on web.

##### API Reference

There are functions available in @devvit/web/client

- isImmersiveMode() - Checks if the app is currently in immersive mode.

```typescript
import { isImmersiveMode } from '@devvit/web/client';

// Conditionally render UI based on mode
if (isImmersiveMode()) {
  showFullscreenControls();
} else {
  showCompactView();
}
```

- requestImmersiveMode(event) - Transition from inline to immersive mode presentation. Must be called from a user-initiated event (click, touch, etc.). In react, you must user event.nativeEvent

```tsx
import { requestImmersiveMode } from '@devvit/web/client';

// Vanilla JavaScript
button.addEventListener('click', async (event) => {
  try {
    await requestImmersiveMode(event);
    console.log('Entered immersive mode');
  } catch (error) {
    console.error('Failed to enter immersive mode:', error);
  }
});

// React - use nativeEvent
function GameComponent() {
  const handleStartGame = async (event: React.MouseEvent) => {
    try {
      await requestImmersiveMode(event.nativeEvent);
      // Navigate or update state
    } catch (error) {
      // Handle error gracefully
    }
  };

  return <button onClick={handleStartGame}>Start Game</button>;
}
```

- exitImmersiveMode(nativeEvent) - Transition from immersive back to inline mode presentation. Must be called from a user-initiated event. In react, you must user event.nativeEvent

```typescript
import { exitImmersiveMode } from '@devvit/web/client';

// Add escape key handler
document.addEventListener('keydown', async (event) => {
  if (event.key === 'Escape') {
    await exitImmersiveMode(event);
  }
});
```

- addImmersiveModeChangeEventListener(callback: (mode: 'inline' | 'immersive') => void) and removeImmersiveModeChangeEventListener(callback) - Listen for mode changes to update your UI accordingly.

```typescript
import {
  addImmersiveModeChangeEventListener,
  removeImmersiveModeChangeEventListener,
} from '@devvit/web/client';

// React hook example
function useImmersiveMode() {
  const [isImmersive, setIsImmersive] = useState(false);

  useEffect(() => {
    const handleModeChange = (mode: 'inline' | 'immersive') => {
      setIsImmersive(mode === 'immersive');
      document.body.classList.toggle('immersive', mode === 'immersive');
    };

    addImmersiveModeChangeEventListener(handleModeChange);

    return () => {
      removeImmersiveModeChangeEventListener(handleModeChange);
    };
  }, []);

  return isImmersive;
}
```

##### Complete Example

```tsx
// game.tsx
import React, { useState, useEffect } from 'react';
import {
  isImmersiveMode,
  requestImmersiveMode,
  exitImmersiveMode,
  addImmersiveModeChangeEventListener,
  removeImmersiveModeChangeEventListener,
} from '@devvit/web/client';

export function GameApp() {
  const [mode, setMode] = useState<'inline' | 'immersive'>(
    isImmersiveMode() ? 'immersive' : 'inline'
  );
  const [gameStarted, setGameStarted] = useState(false);

  useEffect(() => {
    const handleModeChange = (newMode: 'inline' | 'immersive') => {
      setMode(newMode);

      // Pause game when exiting immersive mode
      if (newMode === 'inline' && gameStarted) {
        pauseGame();
      }
    };

    addImmersiveModeChangeEventListener(handleModeChange);
    return () => removeImmersiveModeChangeEventListener(handleModeChange);
  }, [gameStarted]);

  const handlePlayClick = async (event: React.MouseEvent) => {
    try {
      await requestImmersiveMode(event.nativeEvent);
      setGameStarted(true);
    } catch (error) {
      console.error('Could not enter immersive mode:', error);
      // Fallback: start game inline
      setGameStarted(true);
    }
  };

  const handleExitClick = async (event: React.MouseEvent) => {
    try {
      await exitImmersiveMode(event.nativeEvent);
    } catch (error) {
      console.error('Could not exit immersive mode:', error);
    }
  };

  if (mode === 'inline') {
    return (
      <div className="inline-view">
        <h2>Epic Adventure</h2>
        <p>Tap to play in fullscreen!</p>
        <button onClick={handlePlayClick} className="play-button">
          Play Now
        </button>
      </div>
    );
  }

  return (
    <div className="immersive-view">
      <button onClick={handleExitClick} className="exit-button">
        ‚úï Exit
      </button>
      <GameCanvas />
    </div>
  );
}
```


---

import DevvitWebArch from '../../assets/devvit_web/devvit_web_arch.png';

# Devvit Web

Devvit Web includes an easy way to build Devvit apps using a standard web stack.

## What it is

Devvit Web allows developers to build Devvit apps just like you would for the web. At the core, Devvit Web provides:

- **A standard web app** that allows you to build with industry-standard frameworks and technologies (like React, Three.js, or Phaser).
- **Server endpoints** that you define to communicate between the webview client and the Devvit server, using industry-standard frameworks and technologies (like Express.js, Koa, etc.).
- **Devvit configuration** with a traditional client/server split. Devvit capabilities are now in one of three places:
  - A configuration file in devvit.json for defining app metadata, permissions, and capabilities
  - Client capabilities in the @devvit/client SDK
  - Server capabilities, like Redis and Reddit API with the @devvit/server SDK

With Devvit Web, you have continued access to our hosting services, key capabilities like Redis and Reddit API, standard web technologies, and a typical client/server pattern to build your apps.

In addition, since you‚Äôre working with standard web technologies your apps should work with AI tools more effectively.

## Examples

Visit [https://developers.reddit.com/new](https://developers.reddit.com/new) and choose one of our templates or take a look at the github repositories:

* [React](https://github.com/reddit/devvit-template-react)
* [Phaser](https://github.com/reddit/devvit-template-phaser)
* [Three.js](https://github.com/reddit/devvit-template-threejs)
* [Hello World](https://github.com/reddit/devvit-template-hello-world)

## Limitations

As with most experimental features, there are some caveats.

| Limitation                                       | What it means                                                                                                                                                                                                                                                                                         |
| ------------------------------------------------ | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Serverless endpoints                             | The node server will run just long enough to execute your endpoint function and return a response, which means you can‚Äôt use packages that require long-running connections like streaming.                                                                                                           |
| Package limitations                              | Developers cannot use `fs` or external native packages. For now, we recommend using external services over the native dependencies, such as [StreamPot](https://streampot.io/) (instead of ffmpeg) and [OpenAI](https://platform.openai.com/docs/guides/embeddings) (instead of @xenova/transformers) . |
| Single request and single response handling only | Streaming or chunked responses and websockets are not supported. Long-polling is supported if it‚Äôs under the max request time.                                                                                                                                                                        |
| No external requests from your client            | You can‚Äôt have any external requests other than the app's webview domain. All backend responses are locked down to the webview domain via CSP. (Your backend can make external fetch requests though.)                                                                                                |

Devvit Web still has the same technical requirements:

- Server endpoint calls
- Max request time: 30s
- Max payload size: 4MB
- Max response size: 10MB
- HTML/CSS/JS only


## Devvit Web components

Devvit Web uses endpoints between the client and server to make communication similar to standard web apps. A Devvit Web app has three components:

- Client
- Server
- Configuration

Devvit Web templates all have the same file structure:

```tsx
- src
  - client / // contains the webview code
  - server / // endpoints for the client
- devvit.json; // the devvit config file
```

Now, instead of passing messages with postMessage (old way), you‚Äôll define `/api/endpoints` (new way).

### Client folder

This folder includes client-side code. This includes any html/css/javascript and relevant web libraries, and it will appear in a webview inside of a post for Reddit users.

When you want to make server-side calls, or use server-side capabilities, you‚Äôll use fetch and define what happens in your server folder.

### Server folder

This folder includes server-side code. We provide a node server, and you can use typical node server frameworks like Koa or Express. This is where you can access key capabilities like [Redis](../server/redis.mdx), Reddit API client, and [fetch](../server/http-fetch.mdx).

We also provide an authentication middleware so you don‚Äôt have to worry about authentication.

:::note
All server endpoints must start with `/api/` (e.g. `/api/get-something` or `/api/widgets/42`).
:::

<img src={DevvitWebArch} alt="devvit web architecture" style={{ maxWidth: '300px', display: 'block', margin: '0 auto' }} />

### Configuration in `devvit.json`

`devvit.json` is the configuration file for Devvit apps. It defines an app's post configuration, Node.js server configuration, permissions, scheduled jobs, event triggers, menu entries, payments configuration, and project settings. `devvit.json` replaces the legacy `devvit.yaml` configuration. A project should have one or the other but not both.

Learn more about [devvit.json](./devvit_web_configuration)


---

# Configure Your App

The devvit.json file serves as your app's configuration file. Use it to specify entry points, configure features like [event triggers](../server/triggers) and [scheduled actions](../server/scheduler.md), and enable app functionality such as [image uploads](../server/media-uploads.mdx). This page covers all available devvit.json configuration options. A complete devvit.json example file is provided [here](#complete-example).

## devvit.json

The `devvit.json` [schema](https://developers.reddit.com/schema/config-file.v1.json) is available and is self-documented.

All configuration files should include a `$schema` property which many IDEs will use to make suggestions and present documentation:

```json
{
  "$schema": "https://developers.reddit.com/schema/config-file.v1.json"
}
```

## Required properties

Your `devvit.json` must include:

- **`name`** (required): App account name and Community URL slug. Must be 3-16 characters, start with a letter, and contain only lowercase letters, numbers, and hyphens.

Additionally, you must include at least one of:

- **`post`**: For web view apps
- **`server`**: For Node.js server apps
- **`blocks`**: For Blocks

## Configuration sections

### Core properties

| Property  | Type   | Description                                                               | Required         |
| --------- | ------ | ------------------------------------------------------------------------- | ---------------- |
| `name`    | string | App account name and Community URL slug (3-16 chars, `^[a-z][a-z0-9-]*$`) | Yes              |
| `$schema` | string | Schema version for IDE support                                            | No (recommended) |

### App components

| Property | Type   | Description                        | Required                  |
| -------- | ------ | ---------------------------------- | ------------------------- |
| `post`   | object | Custom post/web view configuration | One of post/server/blocks |
| `server` | object | Node.js server configuration       | One of post/server/blocks |
| `blocks` | object | Blocks                             | One of post/server/blocks |

### Permissions & capabilities

| Property          | Type   | Description                    | Required |
| ----------------- | ------ | ------------------------------ | -------- |
| `permissions`     | object | What your app is allowed to do | No       |
| `media`           | object | Static asset configuration     | No       |
| `marketingAssets` | object | Assets for featuring your app  | No       |

### Event handling

| Property    | Type   | Description                  | Required             |
| ----------- | ------ | ---------------------------- | -------------------- |
| `triggers`  | object | Event trigger endpoints      | No (requires server) |
| `scheduler` | object | Scheduled task configuration | No                   |

### UI & interaction

| Property | Type   | Description                               | Required |
| -------- | ------ | ----------------------------------------- | -------- |
| `menu`   | object | Menu items in posts, comments, subreddits | No       |
| `forms`  | object | Form submission endpoints                 | No       |

### Development

| Property | Type   | Description               | Required |
| -------- | ------ | ------------------------- | -------- |
| `dev`    | object | Development configuration | No       |

## Detailed configuration

### Post configuration

Configure web views for custom post types:

```json
{
  "post": {
    "dir": "public",
    "entrypoints": {
      "default": {
        "entry": "index.html",
        "height": "tall"
      }
    }
  }
}
```

**Properties:**

- `dir` (string): Client directory for web view assets (default: `"public"`)
- `entrypoints` (object): Map of named entrypoints for post rendering
  - Must include a `"default"` entrypoint
  - `entry` (string): HTML file path or `/api/` endpoint
  - `height` (enum): `"regular"` or `"tall"` (default: `"regular"`)

### Server configuration

Configure Node.js server functionality:

```json
{
  "server": {
    "entry": "src/server/index.js"
  }
}
```

**Properties:**

- `entry` (string): Server bundle filename (default: `"src/server/index.js"`)

### Permissions configuration

Control what your app can access:

```json
{
  "permissions": {
    "http": {
      "enable": true,
      "domains": ["example.com", "api.github.com"]
    },
    "media": true,
    "payments": false,
    "realtime": false,
    "redis": true,
    "reddit": {
      "enable": true,
      "asUser": ["SUBMIT_POST", "SUBMIT_COMMENT"]
    }
  }
}
```

**HTTP plugin:**

- `enable` (boolean): Enable HTTP plugin (default: `true`)
- `domains` (array): Allowed domains for `fetch()` calls

**Reddit API plugin:**

- `enable` (boolean): Enable Reddit API (default: `true`)
- `scope` (enum): `"user"` or `"moderator"` (default: `"user"`)
- `asUser` (array): APIs to execute as user account

**Other permissions:**

- `media` (boolean): Enable media uploads (default: `false`)
- `payments` (boolean): Enable payments plugin (default: `false`)
- `realtime` (boolean): Enable realtime messaging (default: `false`)
- `redis` (boolean): Enable Redis storage (default: `false`)

### Triggers configuration

Handle Reddit events:

```json
{
  "triggers": {
    "onPostCreate": "/internal/triggers/post-create",
    "onCommentSubmit": "/internal/triggers/comment-submit",
    "onModAction": "/internal/triggers/mod-action"
  }
}
```

**Available triggers:**

- `onAppInstall`, `onAppUpgrade`
- `onPostCreate`, `onPostDelete`, `onPostSubmit`, `onPostUpdate`, `onPostReport`, `onPostFlairUpdate`, `onPostNsfwUpdate`, `onPostSpoilerUpdate`
- `onCommentCreate`, `onCommentDelete`, `onCommentSubmit`, `onCommentUpdate`, `onCommentReport`
- `onModAction`, `onModMail`
- `onAutomoderatorFilterPost`, `onAutomoderatorFilterComment`

**Note:** All trigger endpoints must start with `/internal/` and will receive POST requests with JSON data.

### Menu configuration

Add menu items to subreddit interfaces:

```json
{
  "menu": {
    "items": [
      {
        "label": "Approve Post",
        "description": "Quickly approve this post",
        "forUserType": "moderator",
        "location": ["post"],
        "endpoint": "/internal/menu/approve-post",
        "postFilter": "none"
      },
      {
        "label": "Report Issue",
        "description": "Report a problem with this post",
        "forUserType": "user",
        "location": ["post", "comment"],
        "endpoint": "/internal/menu/report-issue"
      }
    ]
  }
}
```

**Menu item properties:**

- `label` (string): Display text (required)
- `description` (string): Short description
- `forUserType` (enum): `"moderator"` or `"user"` (default: `"moderator"`)
- `location` (string|array): Where menu appears (`"post"`, `"comment"`, `"subreddit"`)
- `endpoint` (string): Internal endpoint to call (required)
- `postFilter` (enum): `"none"` or `"currentApp"` (default: `"none"`)

### Scheduler configuration

Configure scheduled tasks:

```json
{
  "scheduler": {
    "tasks": {
      "daily-cleanup": {
        "endpoint": "/internal/cron/daily-cleanup",
        "cron": "0 2 * * *"
      },
      "hourly-check": {
        "endpoint": "/internal/cron/hourly-check",
        "cron": "0 * * * *",
        "data": {
          "checkType": "health"
        }
      },
      "manual-task": "/internal/cron/manual-task"
    }
  }
}
```

**Task configuration:**

- `endpoint` (string): Internal endpoint to call (required)
- `cron` (string): Cron schedule (optional, for automatic scheduling)
- `data` (object): Additional data passed to cron tasks (optional)

**Cron format:** Standard five-part (`0 2 * * *`) or six-part (`*/30 * * * * *`) format.

### Forms configuration

Map form identifiers to submission endpoints:

```json
{
  "forms": {
    "contact_form": "/internal/forms/contact",
    "feedback_form": "/internal/forms/feedback"
  }
}
```

### Marketing assets

Configure app presentation:

```json
{
  "marketingAssets": {
    "icon": "assets/icon.png"
  }
}
```

**Properties:**

- `icon` (string): Path to 1024x1024 PNG icon (required)

### Development configuration

Configure development settings:

```json
{
  "dev": {
    "subreddit": "my-test-subreddit"
  }
}
```

**Properties:**

- `subreddit` (string): Default development subreddit (can be overridden by `DEVVIT_SUBREDDIT` env var)

## Migration from `devvit.yaml`

1. Create a new `devvit.json` file in the project root.
2. Copy over the `name` property from `devvit.yaml`.
3. Delete `devvit.yaml`.
4. Move configuration from `Devvit.configure()` calls to `permissions`. For example, if the app called `Devvit.configure({redis: true})` set `permissions.redis` to `true` in `devvit.json`.
5. If the app has a web view, set `post` in `devvit.json` and either configure `post.entry` to `webroot/` or to your build output directory. Optionally, delete calls to `Devvit.addCustomPostType()` and `Devvit.addMenuItem()`.
6. If the app has a Node.js server, set `server` in `devvit.json`.
7. (Optional) Set `blocks.entry` to `src/main.tsx` (or `src.main.ts`) to continue using `@devvit/public-api` legacy APIs.

## Validation rules

The `devvit.json` configuration is validated against the JSON Schema at build time. Many IDEs will also underline errors as you write. Common validation errors include:

- **JSON Syntax:** Adding comments or trailing commas (unsupported by JSON)
- **Required Properties:** Missing the required `name` property
- **App Components:** Missing at least one of `post`, `server`, or `blocks`
- **Dependencies:** Missing `server` when `triggers` is specified
- **File References:** Missing files referenced in `devvit.json`
- **Permissions:** Missing required permissions for used features
- **Pattern Validation:** Invalid patterns for names, paths, or endpoints

## Best practices

1. **Always include the `$schema` property** for IDE autocompletion and validation.
2. **Use specific permission scopes.** Only request permissions your app actually uses.
3. **Set appropriate menu scopes.** Consider whether features should be available to all users or just moderators.
4. **Validate endpoints.** Ensure all internal endpoints start with `/internal/`.
5. **Use meaningful names.** Choose descriptive names for entrypoints, tasks, and forms.
6. **Test configurations.** Validate your config with `devvit build` before deployment.

## Environment variables

- `DEVVIT_SUBREDDIT`: Override the `dev.subreddit` value used during `devvit playtest`.
- `DEVVIT_APP_NAME`: Override the `name` value used during `devvit playtest` (and other similar commands).

## Complete example

```json
{
  "$schema": "https://developers.reddit.com/schema/config-file.v1.json",
  "name": "my-awesome-app",
  "post": {
    "dir": "public",
    "entrypoints": {
      "default": {
        "entry": "index.html",
        "height": "tall"
      }
    }
  },
  "server": {
    "entry": "src/server/index.js"
  },
  "permissions": {
    "http": {
      "enable": true,
      "domains": ["api.example.com"]
    },
    "redis": true
  },
  "triggers": {
    "onPostCreate": "/internal/triggers/post-create"
  },
  "menu": {
    "items": [
      {
        "label": "Approve",
        "forUserType": "moderator",
        "location": "post",
        "endpoint": "/internal/menu/approve"
      }
    ]
  },
  "scheduler": {
    "tasks": {
      "daily-cleanup": {
        "endpoint": "/internal/cron/cleanup",
        "cron": "0 2 * * *"
      }
    }
  },
  "marketingAssets": {
    "icon": "assets/icon.png"
  },
  "dev": {
    "subreddit": "my-test-sub"
  }
}
```


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Toasts

Display temporary notification messages to users at the bottom of the screen.

## Overview

Toasts are brief, non-intrusive messages that appear temporarily at the bottom of the screen to provide feedback to users about their actions. They automatically disappear after a few seconds and are ideal for confirming successful operations or displaying status updates.

**For most toast interactions, use the direct client library functions.** These provide immediate feedback and are perfect for user interactions within your app components.

:::note
Toasts will not work from scheduled jobs or triggers.
:::

## Toast appearance types

| Appearance | Description                                               |
| ---------- | --------------------------------------------------------- |
| `neutral`  | Default gray appearance for general notifications         |
| `success`  | Green appearance for successful operations               |

## Basic toast usage

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts
  import { showToast } from '@devvit/web/client';

  // Simple text toast
  showToast('Operation completed successfully!');

  // Toast with custom appearance
  showToast({
    text: 'Data saved successfully!',
    appearance: 'success', // 'neutral' | 'success'
  });

  // Use in button handlers or user interactions
  function handleButtonClick() {
    try {
      // Perform some operation
      processUserData();
      
      showToast({
        text: 'Your data has been processed!',
        appearance: 'success'
      });
    } catch (error) {
      showToast('Something went wrong. Please try again.');
    }
  }
  ```

  ### Parameters

  **`showToast(textOrToast)`**

  - `textOrToast`: Either a string message or a `Toast` object

  **Toast Object Properties:**

  - `text` (string): The message to display
  - `appearance` (string, optional): The visual style (`'neutral'` | `'success'`). Defaults to `'neutral'`

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```ts
  import { Devvit } from '@devvit/public-api';

  // Example with menu action
  Devvit.addMenuItem({
    label: 'Save Data',
    location: 'post',
    forUserType: 'moderator',
    onPress: async (event, context) => {
      try {
        // Perform some operation
        await performAction();
        
        // Show success toast
        context.ui.showToast({
          text: 'Data saved successfully!',
          appearance: 'success'
        });
      } catch (error) {
        // Show error toast
        context.ui.showToast('Something went wrong. Please try again.');
      }
    },
  });

  // Example in blocks
  Devvit.addCustomPostType({
    name: 'My Custom Post',
    render: (context) => {
      return (
        <vstack>
          <button
            onPress={() => {
              context.ui.showToast('Button clicked!');
            }}
          >
            Click me
          </button>
        </vstack>
      );
    },
  });
  ```

  ### Parameters

  **`context.ui.showToast(textOrToast)`**

  - `textOrToast`: Either a string message or a `Toast` object

  **Toast Object Properties:**

  - `text` (string): The message to display
  - `appearance` (string, optional): The visual style (`'neutral'` | `'success'`). Defaults to `'neutral'`

  </TabItem>
</Tabs>

:::tip Menu response toasts
For toasts in menu response workflows (when you need server processing before showing toasts), see the [Menu Actions](./menu-actions.mdx) documentation.
:::

## Best practices

- Keep toast messages concise and clear
- Avoid showing multiple toasts in quick succession
- Don't rely on toasts for critical information that users must see


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Overview

Client-side effects enable your Devvit app to provide interactive feedback and navigation to users. These effects include showing toasts, displaying forms, navigating to different pages, and more.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  Import client functions from `@devvit/web/client`:

  ```ts
  import { showToast, showForm, navigateTo } from '@devvit/web/client';

  // Show a toast notification
  showToast('Hello from Devvit Web!');

  // Navigate to a URL
  navigateTo('https://www.reddit.com/r/webdev');

  // Show a form and handle response
  const result = await showForm({
    form: {
      fields: [
        {
          type: 'string',
          name: 'username',
          label: 'Username'
        }
      ]
    }
  });
  
  if (result) {
    console.log('Form submitted:', result.username);
  }
  ```

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  
  Use context methods in event handlers and component render functions:

  ```tsx
  import { Devvit } from '@devvit/public-api';

  // In a custom post component
  Devvit.addCustomPostType({
    name: 'Interactive Post',
    render: (context) => {
      return (
        <vstack height="100%" alignment="middle center">
          <button
            onPress={() => {
              context.ui.showToast('Button clicked!');
            }}
          >
            Click me
          </button>
          <button
            onPress={() => {
              context.ui.showForm({
                title: 'User Input',
                fields: [
                  {
                    type: 'string',
                    name: 'username',
                    label: 'Username'
                  }
                ]
              }, (values) => {
                context.ui.showToast(`Hello ${values.username}!`);
              });
            }}
          >
            Show Form
          </button>
        </vstack>
      );
    },
  });
  ```

  </TabItem>
</Tabs>

## Available client effects

| Effect | Description | Devvit Web | Devvit Blocks |
|--------|-------------|------------|---------------|
| **Toast** | Show temporary notification messages | `showToast()` | `context.ui.showToast()` |
| **Form** | Display interactive forms with promise-based responses | `showForm()` | `context.ui.showForm()` |
| **Navigation** | Redirect to Reddit content or external URLs | `navigateTo()` | `context.ui.navigateTo()` |

:::note When to use client library functions
You should only use client library functions in response to a user-initiated action.
:::

## Menu responses

In Devvit Web, menu items can respond with client effects after server processing.

Menu responses allow you to:
- Process data on the server before showing client effects
- Chain multiple forms together in complex workflows  
- Validate user permissions before allowing actions
- Fetch external data to populate forms or display results

For complete details and examples, see the [Menu Actions](./menu-actions.mdx) documentation.

## Next steps

Explore the specific documentation for each client effect:

- [Toasts](./toasts.mdx) - Temporary notification messages
- [Forms](./forms.mdx) - Interactive user input
- [Navigation](./navigation.mdx) - Redirecting users
- [Realtime](../realtime/overview.md) - Live updates and communication
- Payments (Coming in September) - Transaction handling


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Navigation

Use navigation functions to redirect users to Reddit content or external websites in response to user actions, such as button clicks. You can redirect to a `url` string or to objects such as [`Subreddit`](/api/redditapi/models/classes/Subreddit.md), [`Post`](/api/redditapi/models/classes/Post.md), or [`Comment`](/api/redditapi/models/classes/Comment.md).

**For most navigation interactions, use the direct client library functions.** These provide immediate navigation and are perfect for user interactions within your app components.

:::warning
When linking to Reddit content, the navigation function requires the app account to have access to the content. If the app account does not have access, the redirect will fail.
:::

## Basic navigation

<Tabs>
  <TabItem value="web" label="Devvit Web">
  ```ts
  import { navigateTo } from '@devvit/web/client';
  
  // Navigate to external URLs
  navigateTo('https://www.youtube.com/watch?v=dQw4w9WgXcQ');
  
  // Navigate to Reddit URLs
  navigateTo('https://www.reddit.com/r/movies/comments/tzxev3/');
  
  // Navigate to Reddit objects
  async function goToPost() {
    const post = await fetch('/api/getPost').then(r => r.json());
    navigateTo(post);
  }
  
  // Use in button handlers or user interactions
  function handleNavigateClick() {
    navigateTo('https://www.reddit.com/r/webdev');
  }
  ```

  ### Parameters

  **`navigateTo(target)`**

  - `target`: Either a URL string or a Reddit object (Subreddit, Post, Comment)

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```tsx
  import { Devvit } from '@devvit/public-api';

  Devvit.configure({ redditAPI: true });

  // Navigate to URL
  Devvit.addMenuItem({
    label: 'Navigate to url',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const url = 'https://www.reddit.com/r/movies/comments/tzxev3/';
      context.ui.navigateTo(url);
    },
  });

  // Navigate to subreddit
  Devvit.addMenuItem({
    label: 'Navigate to subreddit',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const subredditId = 't5_2qh1o';
      const subreddit = await context.reddit.getSubredditById(subredditId);
      context.ui.navigateTo(subreddit);
    },
  });

  // Navigate to post
  Devvit.addMenuItem({
    label: 'Navigate to post',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const postId = 't3_tzxev3';
      const post = await context.reddit.getPostById(postId);
      context.ui.navigateTo(post);
    },
  });

  // Navigate to comment
  Devvit.addMenuItem({
    label: 'Navigate to comment',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const commentId = 't1_i426ob1';
      const comment = await context.reddit.getCommentById(commentId);
      context.ui.navigateTo(comment);
    },
  });

  // Interactive post with navigation
  Devvit.addCustomPostType({
    name: 'Navigation Post',
    render: (context) => {
      return (
        <vstack height="100%" alignment="middle center">
          <button
            onPress={async () => {
              const postId = 't3_tzxev3';
              const post = await context.reddit.getPostById(postId);
              context.ui.navigateTo(post);
            }}
          >
            Navigate to post
          </button>
        </vstack>
      );
    },
  });

  // Menu action to create interactive post
  Devvit.addMenuItem({
    label: 'Add navigation post',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const subreddit = await context.reddit.getCurrentSubreddit();
      await context.reddit.submitPost({
        title: 'Navigate to post',
        subredditName: subreddit.name,
        preview: (
          <vstack height="100%" width="100%" alignment="middle center">
            <text>Loading ...</text>
          </vstack>
        ),
      });
      context.ui.showToast('Created post!');
    },
  });
  ```

  ### Parameters

  **`context.ui.navigateTo(target)`**

  - `target`: Either a URL string or a Reddit object (Subreddit, Post, Comment)

  </TabItem>
</Tabs>

:::tip Menu response navigation
For navigation in menu response workflows (when you need server processing before navigation), see the [Menu Actions](./menu-actions.mdx) documentation.
:::

## External URLs

Users see a confirmation dialog before going to external URLs.

![Confirmation dialog for external links](../../assets/capabilities/adding-links/adding-links-external-link-dialog.png)

## Limitations

- `url` must be http/https
- `url` must have a domain


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Menu Actions

Add an item to the three dot menu for posts, comments, or subreddits. Menu actions can perform immediate client effects or trigger server processing followed by client effects.

![Subreddit menu actions](../../assets/capabilities/menu-actions/menu-actions-subreddit.png)

## Basic Menu Actions

**For most menu actions, use direct client effects.** These provide immediate responses and are perfect for simple actions that don't require server processing.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Menu items defined in devvit.json:**

  ```json title="devvit.json"
  {
    "menu": {
      "items": [
        {
          "description": "Show user information",
          "endpoint": "/internal/menu/show-info",
          "location": "post"
        }
      ]
    }
  }
  ```

  **Simple endpoint with direct client effects:**

  ```ts title="server/index.ts"
  router.post("/internal/menu/show-info", async (_req, res) => {
    // Simple actions don't need server processing
    res.json({
      showToast: 'Menu action clicked!'
    });
  });
  ```

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  
  ```tsx
  import { Devvit } from '@devvit/public-api';

  // Simple menu action with direct client effects
  Devvit.addMenuItem({
    label: 'Show user info',
    location: 'post', // 'post', 'comment', 'subreddit', or array
    onPress: async (event, context) => {
      // Direct client effect - no server processing needed  
      context.ui.showToast('Menu action clicked!');
    },
  });

  // Menu action with form
  const surveyForm = Devvit.createForm(
    {
      fields: [
        {
          type: 'string',
          name: 'feedback',
          label: 'Your feedback',
        },
      ],
    },
    (event, context) => {
      // onSubmit handler
      context.ui.showToast({ text: `Thanks for the feedback: ${event.values.feedback}` });
    }
  );

  Devvit.addMenuItem({
    label: 'Quick survey',
    location: 'subreddit',
    forUserType: 'moderator', // Optional: restrict to moderators
    onPress: async (event, context) => {
      context.ui.showForm(surveyForm);
    },
  });
  ```

  </TabItem>
</Tabs>

## Supported Contexts

You can decide where the menu action shows up by specifying the location property.

| Property               | Values                         | Description                                                                     |
| ---------------------- | ------------------------------ | ------------------------------------------------------------------------------- |
| location (required)    | `comment`, `post`, `subreddit` | Determines where the menu action appears.                    |
| postFilter (optional)  | `currentApp`                   | Shows the action created by your app. The default is no filtering.              |
| forUserType (optional) | `moderator`                    | Specifies the user types that can see the menu action. The default is everyone. |

:::note
For moderator permission security, when opening a form from a menu action with `forUserType: moderator`, the user initiating the action must complete all actions within 10 minutes.
:::

## Menu responses

In Devvit Web, your menu item should respond with a client side effect to give feedback to users. This is available as a UIResponse as you do not have access to the `@devvit/web/client` library from your server endpoints.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Menu items with server processing:**

  ```json title="devvit.json"
  {
    "menu": {
      "items": [
        {
          "label": "Process and validate data",
          "endpoint": "/internal/menu/complex-action",
          "forUserType": "moderator",
          "location": "subreddit"
        }
      ]
    }
  }
  ```

  ```ts title="server/index.ts"
  import { UIResponse } from '@devvit/web/shared';
  
  router.post("/internal/menu/complex-action", async (_req, res: Response<UIResponse>) => {
    try {
      // Perform server-side processing
      const userData = await validateAndProcessData();
      
      // Show form with server-fetched data
      res.json({
        showForm: {
          name: 'processForm',
          form: {
            fields: [
              {
                type: 'string',
                name: 'processedData',
                label: 'Processed Data',
              },
            ],
          },
          data: { processedData: userData.processed }
        }
      });
    } catch (error) {
      res.json({
        showToast: 'Processing failed. Please try again.'
      });
    }
  });
  ``` 
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  
  For Devvit Blocks, use the direct context approach even for complex workflows:

  ```tsx
  Devvit.addMenuItem({
    label: 'Process and validate data',
    location: 'post', // 'post', 'comment', 'subreddit', or array
    forUserType: 'moderator', // Optional: restrict to moderators
    onPress: async (event, context) => {
      try {
        // Perform server-side processing
        const userData = await validateAndProcessData();
        
        // Show form with server-fetched data
        const result = await context.ui.showForm({
          fields: [
            {
              type: 'string',
              name: 'processedData',
              label: 'Processed Data',
            },
          ],
        }, (values) => {
          context.ui.showToast(`Processed: ${values.processedData}`);
        });
      } catch (error) {
        context.ui.showToast('Processing failed. Please try again.');
      }
    },
  });
  ```
  </TabItem>
</Tabs>

### Menu response examples

Menu responses can trigger any client effect after server processing:

**Show toast after processing:**
```ts
res.json({
  showToast: {
    text: 'Processing completed!',
    appearance: 'success'
  }
});
```

**Navigate after data fetching:**
```ts
const post = await reddit.getPostById(postId);
res.json({
  navigateTo: post
});
```

**Chain multiple forms:**
```ts


// First form response leads to second form
res.json({
  showForm: {
    name: 'secondForm',
    form: { fields: [...] },
    data: { fromStep1: processedData }
  }
});
```

## Limitations

- A sort order of actions in the context menu can't be specified.
- The context, name, and description fields do not support dynamic logic.


---

import Tabs from '@theme/Tabs';
import TabItem from '@theme/TabItem';

# Forms

A form lets your app ask users to input and submit data. Forms can be defined with a simple [form object](#form-object) that takes a [list of fields](#supported-fields-types), and return user responses directly as promises.

![A form dialog](../../assets/capabilities/forms/forms-dialog.png)

## Using forms

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Promise-based forms:**
  ```ts title="client/index.ts"
  import { showForm } from '@devvit/web/client';

  // Show form and get user response directly
  const result = await showForm({
    form: {
      fields: [
        {
          type: 'string',
          name: 'name',
          label: 'Name',
        },
      ],
    },
    data: { name: 'Default value' } // Optional initial data
  });

  // Handle form submission result immediately
  if (result) {
    const { name } = result;
    
    // Process the data directly
    console.log(`User entered: ${name}`);
    
    // Chain additional actions
    await fetch('/api/save-name', {
      method: 'POST',
      body: JSON.stringify({ name })
    });
    
    // Or show another form in sequence
    const step2 = await showForm({
      form: {
        fields: [
          {
            type: 'string',
            name: 'food',
            label: 'Favorite food?',
          },
        ],
      }
    });
    
    if (step2) {
      console.log(`Multi-step complete: ${name}, ${step2.food}`);
    }
  } else {
    console.log('User cancelled the form');
  }
  ```

  ### Parameters

  **`showForm(options)` ‚Üí Returns Promise**
  - `form` (Form): The form specification object
  - `data` (FormValues, optional): Initial form field values
  - **Returns**: `Promise<FormValues | null>` - Resolves with form data or null if cancelled

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```tsx
  import { Devvit, useState, useForm } from '@devvit/public-api';

  // Interactive post with form
  Devvit.addCustomPostType({
    name: 'FormExample',
    render: (context) => {
      const [name, setName] = useState('unknown');

      const myForm = useForm(
        {
          fields: [
            {
              type: 'string',
              name: 'name',
              label: 'Name',
            },
          ],
        },
        (values) => {
          // onSubmit handler
          setName(values.name);
        }
      );

      return (
        <vstack gap="medium" height="100%" alignment="middle center">
          <text>Hello {name}!</text>
          <button
            onPress={() => {
              context.ui.showForm(myForm);
            }}
          >
            Set name
          </button>
        </vstack>
      );
    },
  });

  // Menu action with form
  const myForm = Devvit.createForm(
    {
      fields: [
        {
          type: 'string',
          name: 'food',
          label: 'What is your favorite food?',
        },
      ],
    },
    (event, context) => {
      // onSubmit handler
      context.ui.showToast({ text: event.values.food });
    }
  );

  Devvit.addMenuItem({
    label: 'Show a form',
    location: 'subreddit',
    onPress: async (_event, context) => {
      context.ui.showForm(myForm);
    },
  });
  ```

  ### Methods

  **`context.ui.showForm(formConfig, onSubmit)`** - For interactive posts
  - `formConfig` (Form): The form specification object
  - `onSubmit` (function): Callback function when form is submitted

  **`Devvit.createForm(formConfig, onSubmit)`** - For menu actions
  - `formConfig` (Form): The form specification object  
  - `onSubmit` (function): Callback function when form is submitted

  </TabItem>
</Tabs>

## Menu Response Forms

For forms that open from a menu item, you can use menu responses. This is useful since you do not have access to the `@devvit/web/client` library from a menu item endpoint.

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Configure forms in devvit.json:**
  ```json title="devvit.json"
  {
    "forms": {
      "nameForm": "/internal/form/name-submit",
      "reviewForm": "/internal/form/review-submit"
    }
  }
  ```

  **Server endpoint that shows form via menu response:**
  ```ts title="server/index.ts"
  import { UIResponse } from '@devvit/web/shared';

  // Menu action that triggers menu response form
  router.post("/internal/menu/start-workflow", async (_req, res: Response<UIResponse>) => {
    // Server processing before showing form
    const userData = await fetchUserData();
    
    res.json({
      showForm: {
        name: 'nameForm',
        form: {
          fields: [
            {
              type: 'string',
              name: 'name',
              label: 'Name',
            },
          ],
        },
        data: { name: userData.name } // Pre-populate from server
      }
    });
  });

  // Form submission handler that can chain to another form
  router.post("/internal/form/name-submit", async (req, res: Response<UIResponse>) => {
    const { name } = req.body;
    
    // Server processing
    await saveUserName(name);
    
    // Show next form in workflow
    res.json({
      showForm: {
        name: 'reviewForm',
        form: {
          fields: [
            {
              type: 'paragraph',
              name: 'review',
              label: 'How was your experience?',
            },
          ],
        }
      }
    });
  });

  router.post("/internal/form/review-submit", async (req, res: Response<UIResponse>) => {
    const { review } = req.body;
    
    await saveReview(review);
    
    res.json({
      showToast: 'Thank you for your feedback!'
    });
  });
  ```

  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  
  For Devvit Blocks, use the standard promise-based approach even in menu actions:

  ```tsx
  Devvit.addMenuItem({
    label: 'Multi-step workflow',
    location: 'subreddit',
    onPress: async (_event, context) => {
      // Step 1: Get user data from server
      const userData = await fetchUserData();
      
      // Step 2: Show form with server data
      const step1 = await context.ui.showForm({
        fields: [
          {
            type: 'string',
            name: 'name',
            label: 'Name',
          },
        ],
        data: { name: userData.name }
      });
      
      if (!step1) return;
      
      // Step 3: Save and continue to next form
      await saveUserName(step1.name);
      
      const step2 = await context.ui.showForm({
        fields: [
          {
            type: 'paragraph',
            name: 'review',
            label: 'How was your experience?',
          },
        ],
      });
      
      if (step2) {
        await saveReview(step2.review);  
        context.ui.showToast('Thank you for your feedback!');
      }
    },
  });
  ```

  </TabItem>
</Tabs>


## Form object

The form object enables you to customize the form container and the [list of form fields](#supported-fields-types) included. The form object structure is the same for both Devvit Web and Devvit Blocks.

#### Usage

```tsx
const myForm = {
  title: 'My form',
  description: 'This is my form. There are many like it, but this one is mine.',
  fields: [
    {
      type: 'string',
      name: 'food',
      label: 'What is your favorite food?',
    },
    {
      type: 'string',
      name: 'drink',
      label: 'What is your favorite drink?',
    },
  ],
  acceptLabel: 'Submit',
  cancelLabel: 'Cancel',
};
```

#### Supported properties

| Property      | Supported types      | Description                                   |
| :------------ | :------------------- | :-------------------------------------------- |
| `title`       | `string` `undefined` | An optional title for the form                |
| `description` | `string` `undefined` | An optional description for the form          |
| `fields`      | `FormField[]`        | The fields that will be displayed in the form |
| `acceptLabel` | `string` `undefined` | An optional label for the submit button       |
| `cancelLabel` | `string` `undefined` | An optional label for the cancel button       |

## Supported fields types

The following field types are supported: [String](#string), [Select](#select), [Paragraph](#paragraph), [Number](#number), [Boolean](#boolean), [Image](#image), and [Group](#group).

### String

A single-line text input.

![String input](../../assets/capabilities/forms/forms-string.png)

#### Usage

```ts
const stringField = {
  type: 'string',
  name: 'title',
  label: 'Tournament title',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/api/public-api/type-aliases/SettingScopeType) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `placeholder`  | `string` `undefined`                                                              | Placeholder text for display before a value is present.                                                                                                          |
| `isSecret`     | `boolean` `undefined`                                                             | Makes the form field secret.                                                                                                                                     |

### Select

A dropdown menu with predefined options.

![Select input](../../assets/capabilities/forms/forms-select.png)

#### Usage

```ts
const selectField = {
  type: 'select',
  name: 'interval',
  label: 'Update the leaderboard',
  options: [
    { label: 'Hourly', value: 'hourly' },
    { label: 'Daily', value: 'daily' },
    { label: 'Weekly', value: 'weekly' },
    { label: 'Monthly', value: 'monthly' },
    { label: 'Yearly', value: 'yearly' },
  ],
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `options`      | `FieldConfig_Selection_Item[]`                                                    | The list of options available.                                                                                                                                   |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` string[]` `undefined`                                                           | The default value of the field. Note that the default value is wrapped in an array to support multiple selected values.                                          |
| `scope`        | [`SettingScopeType`](/api/public-api/type-aliases/SettingScopeType) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `multiSelect`  | `boolean` `undefined`                                                             | Enables users to select more than 1 item from the set.                                                                                                           |

### Paragraph

A multi-line text input for longer responses.

![Paragraph input](../../assets/capabilities/forms/forms-paragraph.png)

#### Usage

```ts
const paragraphField = {
  type: 'paragraph',
  name: 'description',
  label: 'Description',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/api/public-api/type-aliases/SettingScopeType) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `placeholder`  | `string` `undefined`                                                              | Placeholder text for display before a value is present.                                                                                                          |
| `lineHeight`   | `number` `undefined`                                                              | Sets the field height by number of lines.                                                                                                                        |

### Number

An input for numerical values.

![Number input](../../assets/capabilities/forms/forms-number.png)

#### Usage

```ts
const numberField = {
  type: 'number',
  name: 'tokens',
  label: 'Token balance',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `required`     | `boolean` `undefined`                                                             | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/api/public-api/type-aliases/SettingScopeType) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |

### Boolean

A yes/no or true/false type input.

![Boolean input](../../assets/capabilities/forms/forms-boolean.png)

#### Usage

```ts
const booleanField = {
  type: 'boolean',
  name: 'enable',
  label: 'Enable the event',
};
```

#### Properties

| Property       | Supported types                                                                   | Description                                                                                                                                                      |
| :------------- | :-------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`         | `string`                                                                          | The desired field type.                                                                                                                                          |
| `name`         | `string`                                                                          | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`        | `string`                                                                          | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`     | `string` `undefined`                                                              | An optional help text that will be displayed below the field.                                                                                                    |
| `disabled`     | `boolean` `undefined`                                                             | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `defaultValue` | ` ValueType` `undefined`                                                          | The default value of the field.                                                                                                                                  |
| `scope`        | [`SettingScopeType`](/api/public-api/type-aliases/SettingScopeType) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |

### Image

An image upload field.

![Image input](../../assets/capabilities/forms/forms-image.png)

#### Usage

```ts
const imageField = {
  type: 'image', // This tells the form to expect an image
  name: 'myImage',
  label: 'Image goes here',
  required: true,
};
```

#### Properties

| Property      | Supported types                                                                | Description                                                                                                                                                      |
| :------------ | :----------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `type`        | `string`                                                                       | The desired field type.                                                                                                                                          |
| `name`        | `string`                                                                       | The name of the field. This will be used as the key in the `values` object when the form is submitted.                                                           |
| `label`       | `string`                                                                       | The label of the field. This will be displayed to the user.                                                                                                      |
| `helpText`    | `string` `undefined`                                                           | An optional help text that will be displayed below the field.                                                                                                    |
| `required`    | `boolean` `undefined`                                                          | If true the field will be required and the user will not be able to submit the form without filling it in. Defaults to `false`.                                  |
| `disabled`    | `boolean` `undefined`                                                          | If true the field will be disabled. Defaults to `false`.                                                                                                         |
| `scope`       | [`SettingScopeType`](/api/public-api/type-aliases/SettingScopeType) `undefined` | This indicates whether the field (setting) is an app level or install level setting. App setting values can be used by any installation. `undefined` by default. |
| `placeholder` | `string` `undefined`                                                           | Placeholder text for display before a value is present.                                                                                                          |
| `isSecret`    | `boolean` `undefined`                                                          | Makes the form field secret.                                                                                                                                     |

### Group

A collection of related fields that allows for better readability.

#### Usage

```ts
const groupField = {
  type: 'group',
  label: 'This is a group of input fields',
  fields: [
    {
      type: 'paragraph',
      name: 'description',
      label: 'How would you describe what happened?',
    },
    {
      type: 'number',
      name: 'score',
      label: 'How would you rate your meal on a scale from 1 to 10?',
    },
  ],
};
```

#### Properties

| Property   | Supported types      | Description                                                   |
| :--------- | :------------------- | :------------------------------------------------------------ |
| `type`     | `string`             | The desired field type.                                       |
| `label`    | `string`             | The label of the group that will be displayed to the user.    |
| `fields`   | `FormField[]`        | The fields that will be displayed in the group.               |
| `helpText` | `string` `undefined` | An optional help text that will be displayed below the group. |

## Examples

Below is a collection of common use cases and patterns.

### Dynamic forms

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Client-side approach:**
  ```ts title="client/index.ts"
  import { showForm } from '@devvit/web/client';

  // Get user data and show form with dynamic default values
  const user = await reddit.getCurrentUser();
  
  const result = await showForm({
    form: {
      fields: [
        {
          type: 'string',
          name: 'username',
          label: 'Username',
        },
      ],
    },
    data: {
      username: user?.username || ''
    }
  });

  if (result) {
    // Handle the form result
    console.log(`Hello ${result.username}`);
  }
  ```

  **Server-side approach:**
  ```json title="devvit.json"
  {
    "forms": {
      "dynamicForm": "/internal/form/dynamic-submit"
    }
  }
  ```

  ```ts title="server/index.ts"
  // Endpoint that shows form with dynamic data
  router.post("/internal/menu/show-dynamic-form", async (_req, res: Response<UiResponse>) => {
    const user = await reddit.getCurrentUser();
    
    res.json({
      showForm: {
        name: 'dynamicForm',
        form: {
          fields: [
            {
              type: 'string',
              name: 'username',
              label: 'Username',
            },
          ],
        },
        data: {
          username: user?.username || ''
        }
      }
    });
  });

  // Form submission handler
  router.post("/internal/form/dynamic-submit", async (req, res: Response<UiResponse>) => {
    const { username } = req.body;
    
    res.json({
      showToast: `Hello ${username}`
    });
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```tsx
  import { Devvit } from '@devvit/public-api';

  Devvit.configure({
    redditAPI: true,
  });

  const myForm = Devvit.createForm(
    (data) => {
      return {
        fields: [
          {
            type: 'string',
            name: 'username',
            label: 'Username',
            defaultValue: data.username,
          },
        ],
        // Adding `as const` helps you get accurate types in the onSubmit function below
        // This will only work if the function does not have any branching logic
      } as const;
    },
    (event, context) => {
      context.ui.showToast({
        text: `Hello ${event.values.username}`,
      });
    }
  );

  Devvit.addMenuItem({
    label: 'Show a dynamic form',
    location: 'subreddit',
    onPress: async (_event, context) => {
      const user = await context.reddit.getCurrentUser();
      const username = user?.username;
      context.ui.showForm(myForm, { username });
    },
  });
  ```
  </TabItem>
</Tabs>

### Multi-step forms

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Client-side approach (Promise chaining):**
  ```ts title="client/index.ts"
  import { showForm } from '@devvit/web/client';

  async function multiStepForm() {
    // Step 1: Get name
    const step1Result = await showForm({
      form: {
        fields: [
          {
            type: 'string',
            name: 'name',
            label: "What's your name?",
            required: true,
          },
        ],
      }
    });

    if (!step1Result) return; // User cancelled

    // Step 2: Get food preference  
    const step2Result = await showForm({
      form: {
        fields: [
          {
            type: 'string',
            name: 'food',
            label: "What's your favorite food?",
            required: true,
          },
        ],
      },
      data: { name: step1Result.name } // Pass data from previous step
    });

    if (!step2Result) return; // User cancelled

    // Step 3: Get drink preference
    const step3Result = await showForm({
      form: {
        fields: [
          {
            type: 'string',
            name: 'drink',
            label: "What's your favorite drink?",
            required: true,
          },
        ],
      },
      data: { 
        name: step1Result.name,
        food: step2Result.food
      }
    });

    if (step3Result) {
      // All steps completed - save or process data
      const finalData = {
        ...step1Result,
        ...step2Result, 
        ...step3Result
      };
      
      console.log(`Thanks ${finalData.name}! You like ${finalData.food} and ${finalData.drink}.`);
    }
  }
  ```

  **Server-side approach (Separate endpoints):**
  ```json title="devvit.json"
  {
    "forms": {
      "step1Form": "/internal/form/step1-submit",
      "step2Form": "/internal/form/step2-submit",
      "step3Form": "/internal/form/step3-submit"
    }
  }
  ```

  ```ts title="server/index.ts"
  // Step 1: Name form
  router.post("/internal/form/step1-submit", async (req, res: Response<UiResponse>) => {
    const { name } = req.body;
    
    res.json({
      showForm: {
        name: 'step2Form',
        form: {
          fields: [
            {
              type: 'string',
              name: 'food',
              label: "What's your favorite food?",
              required: true,
            },
          ],
        },
        data: { name } // Pass data to next step
      }
    });
  });

  // Step 2: Food form
  router.post("/internal/form/step2-submit", async (req, res: Response<UiResponse>) => {
    const { name, food } = req.body;
    
    res.json({
      showForm: {
        name: 'step3Form',
        form: {
          fields: [
            {
              type: 'string',
              name: 'drink',
              label: "What's your favorite drink?",
              required: true,
            },
          ],
        },
        data: { name, food } // Pass accumulated data
      }
    });
  });

  // Step 3: Final form
  router.post("/internal/form/step3-submit", async (req, res: Response<UiResponse>) => {
    const { name, food, drink } = req.body;
    
    res.json({
      showToast: `Thanks ${name}! You like ${food} and ${drink}.`
    });
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```tsx
  import { Devvit, useState, useForm } from '@devvit/public-api';

  Devvit.configure({
    redditAPI: true,
  });

  Devvit.addCustomPostType({
    name: 'Multi-step Form',
    render: (context) => {
      const [name, setName] = useState('');
      const [food, setFood] = useState('');
      const [drink, setDrink] = useState('');

      const form3 = useForm(
        {
          fields: [
            {
              type: 'string',
              name: 'drink',
              label: "What's your favorite drink?",
              required: true,
            },
          ],
        },
        (values) => {
          setDrink(values.drink);
        }
      );

      const form2 = useForm(
        {
          fields: [
            {
              type: 'string',
              name: 'food',
              label: "What's your favorite food?",
              required: true,
            },
          ],
        },
        (values) => {
          setFood(values.food);
          context.ui.showForm(form3);
        }
      );

      const form1 = useForm(
        {
          fields: [
            {
              type: 'string',
              name: 'name',
              label: "What's your name?",
              required: true,
            },
          ],
        },
        (values) => {
          setName(values.name);
          context.ui.showForm(form2);
        }
      );

      function restart() {
        setName('');
        setFood('');
        setDrink('');
        context.ui.showForm(form1);
      }

      const isAnswered = name && food && drink;

      return (
        <vstack height="100%" alignment="center middle" gap="none">
          {isAnswered && (
            <>
              <text>Name: {name}</text>
              <text>Favorite food: {food}</text>
              <text>Favorite drink: {drink}</text>
              <spacer size="large" />
              <button onPress={restart}>Restart</button>
            </>
          )}
          {!isAnswered && <button onPress={restart}>Take questionnaire</button>}
        </vstack>
      );
    },
  });
  ```
  </TabItem>
</Tabs>

### One of everything

This example includes one of each of the [supported field types](#supported-fields-types).

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Client-side approach:**
  ```ts title="client/index.ts"
  import { showForm } from '@devvit/web/client';

  const result = await showForm({
    form: {
      title: 'My favorites',
      description: 'Tell us about your favorite food!',
      fields: [
        {
          type: 'string',
          name: 'food',
          label: 'What is your favorite food?',
          helpText: 'Must be edible',
          required: true,
        },
        {
          label: 'About that food',
          type: 'group',
          fields: [
            {
              type: 'number',
              name: 'times',
              label: 'How many times a week do you eat it?',
              defaultValue: 1,
            },
            {
              type: 'paragraph',
              name: 'what',
              label: 'What makes it your favorite?',
            },
            {
              type: 'select',
              name: 'healthy',
              label: 'Is it healthy?',
              options: [
                { label: 'Yes', value: 'yes' },
                { label: 'No', value: 'no' },
                { label: 'Maybe', value: 'maybe' },
              ],
              defaultValue: ['maybe'],
            },
          ],
        },
        {
          type: 'boolean',
          name: 'again',
          label: 'Can we ask again?',
        },
      ],
      acceptLabel: 'Submit',
      cancelLabel: 'Cancel',
    }
  });

  if (result) {
    console.log('Form values:', result);
    // Handle form submission
  }
  ```

  **Server-side approach:**
  ```json title="devvit.json"
  {
    "forms": {
      "everythingForm": "/internal/form/everything-submit"
    }
  }
  ```

  ```ts title="server/index.ts"
  router.post("/internal/form/everything-submit", async (req, res: Response<UiResponse>) => {
    console.log('Form values:', req.body);
    
    res.json({
      showToast: 'Thanks!'
    });
  });

  // Example showing the form
  router.post("/internal/menu/show-everything-form", async (_req, res: Response<UiResponse>) => {
    res.json({
      showForm: {
        name: 'everythingForm',
        form: {
          title: 'My favorites',
          description: 'Tell us about your favorite food!',
          fields: [
            {
              type: 'string',
              name: 'food',
              label: 'What is your favorite food?',
              helpText: 'Must be edible',
              required: true,
            },
            {
              label: 'About that food',
              type: 'group',
              fields: [
                {
                  type: 'number',
                  name: 'times',
                  label: 'How many times a week do you eat it?',
                  defaultValue: 1,
                },
                {
                  type: 'paragraph',
                  name: 'what',
                  label: 'What makes it your favorite?',
                },
                {
                  type: 'select',
                  name: 'healthy',
                  label: 'Is it healthy?',
                  options: [
                    { label: 'Yes', value: 'yes' },
                    { label: 'No', value: 'no' },
                    { label: 'Maybe', value: 'maybe' },
                  ],
                  defaultValue: ['maybe'],
                },
              ],
            },
            {
              type: 'boolean',
              name: 'again',
              label: 'Can we ask again?',
            },
          ],
          acceptLabel: 'Submit',
          cancelLabel: 'Cancel',
        }
      }
    });
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```tsx
  import { Devvit } from '@devvit/public-api';

  const exampleForm = Devvit.createForm(
    {
      title: 'My favorites',
      description: 'Tell us about your favorite food!',
      fields: [
        {
          type: 'string',
          name: 'food',
          label: 'What is your favorite food?',
          helpText: 'Must be edible',
          required: true,
        },
        {
          label: 'About that food',
          type: 'group',
          fields: [
            {
              type: 'number',
              name: 'times',
              label: 'How many times a week do you eat it?',
              defaultValue: 1,
            },
            {
              type: 'paragraph',
              name: 'what',
              label: 'What makes it your favorite?',
            },
            {
              type: 'select',
              name: 'healthy',
              label: 'Is it healthy?',
              options: [
                { label: 'Yes', value: 'yes' },
                { label: 'No', value: 'no' },
                { label: 'Maybe', value: 'maybe' },
              ],
              defaultValue: ['maybe'],
            },
          ],
        },
        {
          type: 'boolean',
          name: 'again',
          label: 'Can we ask again?',
        },
      ],
      acceptLabel: 'Submit',
      cancelLabel: 'Cancel',
    },
    (event, context) => {
      console.log(event.values);
      context.ui.showToast('Thanks!');
    }
  );

  Devvit.addMenuItem({
    location: 'subreddit',
    label: 'One of everything form',
    onPress: (_event, context) => {
      context.ui.showForm(exampleForm);
    },
  });
  ```
  </TabItem>
</Tabs>

### Image uploads

<Tabs>
  <TabItem value="web" label="Devvit Web">
  
  **Client-side approach:**
  ```ts title="client/index.ts"
  import { showForm } from '@devvit/web/client';

  const result = await showForm({
    form: {
      title: 'Upload an image!',
      fields: [
        {
          name: 'myImage',
          type: 'image', // This tells the form to expect an image
          label: 'Image goes here',
          required: true,
        },
      ],
    }
  });

  if (result) {
    const { myImage } = result;
    // returns an i.redd.it URL
    console.log('Image uploaded:', myImage);
    
    // Process the image further
    await fetch('/api/process-image', {
      method: 'POST',
      body: JSON.stringify({ imageUrl: myImage })
    });
  }
  ```

  **Server-side approach:**
  ```json title="devvit.json"
  {
    "forms": {
      "imageForm": "/internal/form/image-submit"
    }
  }
  ```

  ```ts title="server/index.ts"
  router.post("/internal/form/image-submit", async (req, res: Response<UiResponse>) => {
    const { myImage } = req.body;
    // Use the mediaUrl to store in redis and display it in an <image> block, or send to external service to modify
    console.log('Image uploaded:', myImage);
    
    res.json({
      showToast: 'Image uploaded successfully!'
    });
  });
  ```
  </TabItem>
  <TabItem value="blocks" label="Devvit Blocks / Mod Tools">
  ```tsx
  import { Devvit } from '@devvit/public-api';

  const form = Devvit.createForm(
    {
      title: 'Upload an image!',
      fields: [
        {
          name: 'myImage',
          type: 'image', // This tells the form to expect an image
          label: 'Image goes here',
          required: true,
        },
      ],
    },
    (event, context) => {
      // returns an i.redd.it URL
      const imageUrl = event.values.myImage;
    }
  );
  ```
  </TabItem>
</Tabs>
